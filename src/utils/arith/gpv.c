/*****************************************************************************
 * Copyright (C) Queen's University Belfast, ECIT, 2016                      *
 *                                                                           *
 * This file is part of libsafecrypto.                                       *
 *                                                                           *
 * This file is subject to the terms and conditions defined in the file      *
 * 'LICENSE', which is part of this source code package.                     *
 *****************************************************************************/

/*
 * Git commit information:
 *   Author: $SC_AUTHOR$
 *   Date:   $SC_DATE$
 *   Branch: $SC_BRANCH$
 *   Id:     $SC_IDENT$
 */

#include "utils/arith/gpv.h"
#include "utils/arith/sc_poly_mpz.h"
#include "utils/arith/sc_mpz.h"
#include "utils/crypto/prng.h"
#include "utils/arith/sc_math.h"
#include "utils/arith/arith.h"
#include "utils/sampling/sampling.h"
#include "safecrypto_types.h"
#include "safecrypto_private.h"
#include "safecrypto_debug.h"
#include "poly_fft.h"

#include "schemes/sig/falcon/falcon_params.h"
#include "schemes/sig/ens_dlp/ens_dlp_sig_params.h"
#include "schemes/ibe/dlp/dlp_ibe_params.h"

#include "internal.h"
#define NTT_NEEDS_12289
#include "utils/arith/ntt_tables.h"

#include <math.h>

#define DEBUG_GPV               0
#define CRT_NTRU_SOLVE          0
#define SP_PUBLIC_KEY_CREATE    0
#if CRT_NTRU_SOLVE == 1 && SP_PUBLIC_KEY_CREATE == 0
#error "If CRT_NTRU_SOLVE is enabled SP_PUBLIC_KEY_CREATE must also be enabled"
#endif


typedef struct {
        uint32_t p;
        uint32_t g;
        uint32_t s;
} small_prime_t;

static const small_prime_t binary_primes[] = {
        { 2147473409,  383167813,      10239 },
        { 2147389441,  211808905,  471403745 },
        { 2147387393,   37672282, 1329335065 },
        { 2147377153, 1977035326,  968223422 },
        { 2147358721, 1067163706,  132460015 },
        { 2147352577, 1606082042,  598693809 },
        { 2147346433, 2033915641, 1056257184 },
        { 2147338241, 1653770625,  421286710 },
        { 2147309569,  631200819, 1111201074 },
        { 2147297281, 2038364663, 1042003613 },
        { 2147295233, 1962540515,   19440033 },
        { 2147239937, 2100082663,  353296760 },
        { 2147235841, 1991153006, 1703918027 },
        { 2147217409,  516405114, 1258919613 },
        { 2147205121,  409347988, 1089726929 },
        { 2147196929,  927788991, 1946238668 },
        { 2147178497, 1136922411, 1347028164 },
        { 2147100673,  868626236,  701164723 },
        { 2147082241, 1897279176,  617820870 },
        { 2147074049, 1888819123,  158382189 },
        { 2147051521,   25006327,  522758543 },
        { 2147043329,  327546255,   37227845 },
        { 2147039233,  766324424, 1133356428 },
        { 2146988033, 1862817362,   73861329 },
        { 2146963457,  404622040,  653019435 },
        { 2146959361, 1936581214,  995143093 },
        { 2146938881, 1559770096,  634921513 },
        { 2146908161,  422623708, 1985060172 },
        { 2146885633, 1751189170,  298238186 },
        { 2146871297,  578919515,  291810829 },
        { 2146846721, 1114060353,  915902322 },
        { 2146834433, 2069565474,   47859524 },
        { 2146818049, 1552824584,  646281055 },
        { 2146775041, 1906267847, 1597832891 },
        { 2146756609, 1847414714, 1228090888 },
        { 2146744321, 1818792070, 1176377637 },
        { 2146738177, 1118066398, 1054971214 },
        { 2146736129,   52057278,  933422153 },
        { 2146713601,  592259376, 1406621510 },
        { 2146695169,  263161877, 1514178701 },
        { 2146656257,  685363115,  384505091 },
        { 2146650113,  927727032,  537575289 },
        { 2146646017,   52575506, 1799464037 },
        { 2146643969, 1276803876, 1348954416 },
        { 2146603009,  814028633, 1521547704 },
        { 2146572289, 1846678872, 1310832121 },
        { 2146547713,  919368090, 1019041349 },
        { 2146508801,  671847612,   38582496 },
        { 2146492417,  283911680,  532424562 },
        { 2146490369, 1780044827,  896447978 },
        { 2146459649,  327980850, 1327906900 },
        { 2146447361, 1310561493,  958645253 },
        { 2146441217,  412148926,  287271128 },
        { 2146437121,  293186449, 2009822534 },
        { 2146430977,  179034356, 1359155584 },
        { 2146418689, 1517345488, 1790248672 },
        { 2146406401, 1615820390, 1584833571 },
        { 2146404353,  826651445,  607120498 },
        { 2146379777,    3816988, 1897049071 },
        { 2146363393, 1221409784, 1986921567 },
        { 2146355201, 1388081168,  849968120 },
        { 2146336769, 1803473237, 1655544036 },
        { 2146312193, 1023484977,  273671831 },
        { 2146293761, 1074591448,  467406983 },
        { 2146283521,  831604668, 1523950494 },
        { 2146203649,  712865423, 1170834574 },
        { 2146154497, 1764991362, 1064856763 },
        { 2146142209,  627386213, 1406840151 },
        { 2146127873, 1638674429, 2088393537 },
        { 2146099201, 1516001018,  690673370 },
        { 2146093057, 1294931393,  315136610 },
        { 2146091009, 1942399533,  973539425 },
        { 2146078721, 1843461814, 2132275436 },
        { 2146060289, 1098740778,  360423481 },
        { 2146048001, 1617213232, 1951981294 },
        { 2146041857, 1805783169, 2075683489 },
        { 2146019329,  272027909, 1753219918 },
        { 2145986561, 1206530344, 2034028118 },
        { 2145976321, 1243769360, 1173377644 },
        { 2145964033,  887200839, 1281344586 },
        { 2145906689, 1651026455,  906178216 },
        { 2145875969, 1673238256, 1043521212 },
        { 2145871873, 1226591210, 1399796492 },
        { 2145841153, 1465353397, 1324527802 },
        { 2145832961, 1150638905,  554084759 },
        { 2145816577,  221601706,  427340863 },
        { 2145785857,  608896761,  316590738 },
        { 2145755137, 1712054942, 1684294304 },
        { 2145742849, 1302302867,  724873116 },
        { 2145728513,  516717693,  431671476 },
        { 2145699841,  524575579, 1619722537 },
        { 2145691649, 1925625239,  982974435 },
        { 2145687553,  463795662, 1293154300 },
        { 2145673217,  771716636,  881778029 },
        { 2145630209, 1509556977,  837364988 },
        { 2145595393,  229091856,  851648427 },
        { 2145587201, 1796903241,  635342424 },
        { 2145525761,  715310882, 1677228081 },
        { 2145495041, 1040930522,  200685896 },
        { 2145466369,  949804237, 1809146322 },
        { 2145445889, 1673903706,   95316881 },
        { 2145390593,  806941852, 1428671135 },
        { 2145372161, 1402525292,  159350694 },
        { 2145361921, 2124760298, 1589134749 },
        { 2145359873, 1217503067, 1561543010 },
        { 2145355777,  338341402,   83865711 },
        { 2145343489, 1381532164,  641430002 },
        { 2145325057, 1883895478, 1528469895 },
        { 2145318913, 1335370424,   65809740 },
        { 2145312769, 2000008042, 1919775760 },
        { 2145300481,  961450962, 1229540578 },
        { 2145282049,  910466767, 1964062701 },
        { 2145232897,  816527501,  450152063 },
        { 2145218561, 1435128058, 1794509700 },
        { 2145187841,   33505311, 1272467582 },
        { 2145181697,  269767433, 1380363849 },
        { 2145175553,   56386299, 1316870546 },
        { 2145079297, 2106880293, 1391797340 },
        { 2145021953, 1347906152,  720510798 },
        { 2145015809,  206769262, 1651459955 },
        { 2145003521, 1885513236, 1393381284 },
        { 2144960513, 1810381315,   31937275 },
        { 2144944129, 1306487838, 2019419520 },
        { 2144935937,   37304730, 1841489054 },
        { 2144894977, 1601434616,  157985831 },
        { 2144888833,   98749330, 2128592228 },
        { 2144880641, 1772327002, 2076128344 },
        { 2144864257, 1404514762, 2029969964 },
        { 2144827393,  801236594,  406627220 },
        { 2144806913,  349217443, 1501080290 },
        { 2144796673, 1542656776, 2084736519 },
        { 2144778241, 1210734884, 1746416203 },
        { 2144759809, 1146598851,  716464489 },
        { 2144757761,  286328400, 1823728177 },
        { 2144729089, 1347555695, 1836644881 },
        { 2144727041, 1795703790,  520296412 },
        { 2144696321, 1302475157,  852964281 },
        { 2144667649, 1075877614,  504992927 },
        { 2144573441,  198765808, 1617144982 },
        { 2144555009,  321528767,  155821259 },
        { 2144550913,  814139516, 1819937644 },
        { 2144536577,  571143206,  962942255 },
        { 2144524289, 1746733766,    2471321 },
        { 2144512001, 1821415077,  124190939 },
        { 2144468993,  917871546, 1260072806 },
        { 2144458753,  378417981, 1569240563 },
        { 2144421889,  175229668, 1825620763 },
        { 2144409601, 1699216963,  351648117 },
        { 2144370689, 1071885991,  958186029 },
        { 2144348161, 1763151227,  540353574 },
        { 2144335873, 1060214804,  919598847 },
        { 2144329729,  663515846, 1448552668 },
        { 2144327681, 1057776305,  590222840 },
        { 2144309249, 1705149168, 1459294624 },
        { 2144296961,  325823721, 1649016934 },
        { 2144290817,  738775789,  447427206 },
        { 2144243713,  962347618,  893050215 },
        { 2144237569, 1655257077,  900860862 },
        { 2144161793,  242206694, 1567868672 },
        { 2144155649,  769415308, 1247993134 },
        { 2144137217,  320492023,  515841070 },
        { 2144120833, 1639388522,  770877302 },
        { 2144071681, 1761785233,  964296120 },
        { 2144065537,  419817825,  204564472 },
        { 2144028673,  666050597, 2091019760 },
        { 2144010241, 1413657615, 1518702610 },
        { 2143952897, 1238327946,  475672271 },
        { 2143940609,  307063413, 1176750846 },
        { 2143918081, 2062905559,  786785803 },
        { 2143899649, 1338112849, 1562292083 },
        { 2143891457,   68149545,   87166451 },
        { 2143885313,  921750778,  394460854 },
        { 2143854593,  719766593,  133877196 },
        { 2143836161, 1149399850, 1861591875 },
        { 2143762433, 1848739366, 1335934145 },
        { 2143756289, 1326674710,  102999236 },
        { 2143713281,  808061791, 1156900308 },
        { 2143690753,  388399459, 1926468019 },
        { 2143670273, 1427891374, 1756689401 },
        { 2143666177, 1912173949,  986629565 },
        { 2143645697, 2041160111,  371842865 },
        { 2143641601, 1279906897, 2023974350 },
        { 2143635457,  720473174, 1389027526 },
        { 2143621121, 1298309455, 1732632006 },
        { 2143598593, 1548762216, 1825417506 },
        { 2143567873,  620475784, 1073787233 },
        { 2143561729, 1932954575,  949167309 },
        { 2143553537,  354315656, 1652037534 },
        { 2143541249,  577424288, 1097027618 },
        { 2143531009,  357862822,  478640055 },
        { 2143522817, 2017706025, 1550531668 },
        { 2143506433, 2078127419, 1824320165 },
        { 2143488001,  613475285, 1604011510 },
        { 2143469569, 1466594987,  502095196 },
        { 2143426561, 1115430331, 1044637111 },
        { 2143383553,    9778045, 1902463734 },
        { 2143377409, 1557401276, 2056861771 },
        { 2143363073,  652036455, 1965915971 },
        { 2143260673, 1464581171, 1523257541 },
        { 2143246337, 1876119649,  764541916 },
        { 2143209473, 1614992673, 1920672844 },
        { 2143203329,  981052047, 2049774209 },
        { 2143160321, 1847355533,  728535665 },
        { 2143129601,  965558457,  603052992 },
        { 2143123457, 2140817191,    8348679 },
        { 2143100929, 1547263683,  694209023 },
        { 2143092737,  643459066, 1979934533 },
        { 2143082497,  188603778, 2026175670 },
        { 2143062017, 1657329695,  377451099 },
        { 2143051777,  114967950,  979255473 },
        { 2143025153, 1698431342, 1449196896 },
        { 2143006721, 1862741675, 1739650365 },
        { 2142996481,  756660457,  996160050 },
        { 2142976001,  927864010, 1166847574 },
        { 2142965761,  905070557,  661974566 },
        { 2142916609,   40932754, 1787161127 },
        { 2142892033, 1987985648,  675335382 },
        { 2142885889,  797497211, 1323096997 },
        { 2142871553, 2068025830, 1411877159 },
        { 2142861313, 1217177090, 1438410687 },
        { 2142830593,  409906375, 1767860634 },
        { 2142803969, 1197788993,  359782919 },
        { 2142785537,  643817365,  513932862 },
        { 2142779393, 1717046338,  218943121 },
        { 2142724097,   89336830,  416687049 },
        { 2142707713,    5944581, 1356813523 },
        { 2142658561,  887942135, 2074011722 },
        { 2142638081,  151851972, 1647339939 },
        { 2142564353, 1691505537, 1483107336 },
        { 2142533633, 1989920200, 1135938817 },
        { 2142529537,  959263126, 1531961857 },
        { 2142527489,  453251129, 1725566162 },
        { 2142502913, 1536028102,  182053257 },
        { 2142498817,  570138730,  701443447 },
        { 2142416897,  326965800,  411931819 },
        { 2142363649, 1675665410, 1517191733 },
        { 2142351361,  968529566, 1575712703 },
        { 2142330881, 1384953238, 1769087884 },
        { 2142314497, 1977173242, 1833745524 },
        { 2142289921,   95082313, 1714775493 },
        { 2142283777,  109377615, 1070584533 },
        { 2142277633,   16960510,  702157145 },
        { 2142263297,  553850819,  431364395 },
        { 2142208001,  241466367, 2053967982 },
        { 2142164993, 1795661326, 1031836848 },
        { 2142097409, 1212530046,  712772031 },
        { 2142087169, 1763869720,  822276067 },
        { 2142078977,  644065713, 1765268066 },
        { 2142074881,  112671944,  643204925 },
        { 2142044161, 1387785471, 1297890174 },
        { 2142025729,  783885537, 1000425730 },
        { 2142011393,  905662232, 1679401033 },
        { 2141974529,  799788433,  468119557 },
        { 2141943809, 1932544124,  449305555 },
        { 2141933569, 1527403256,  841867925 },
        { 2141931521, 1247076451,  743823916 },
        { 2141902849, 1199660531,  401687910 },
        { 2141890561,  150132350, 1720336972 },
        { 2141857793, 1287438162,  663880489 },
        { 2141833217,  618017731, 1819208266 },
        { 2141820929,  999578638, 1403090096 },
        { 2141786113,   81834325, 1523542501 },
        { 2141771777,  120001928,  463556492 },
        { 2141759489,  122455485, 2124928282 },
        { 2141749249,  141986041,  940339153 },
        { 2141685761,  889088734,  477141499 },
        { 2141673473,  324212681, 1122558298 },
        { 2141669377, 1175806187, 1373818177 },
        { 2141655041, 1113654822,  296887082 },
        { 2141587457,  991103258, 1585913875 },
        { 2141583361, 1401451409, 1802457360 },
        { 2141575169, 1571977166,  712760980 },
        { 2141546497, 1107849376, 1250270109 },
        { 2141515777,  196544219,  356001130 },
        { 2141495297, 1733571506, 1060744866 },
        { 2141483009,  321552363, 1168297026 },
        { 2141458433,  505818251,  733225819 },
        { 2141360129, 1026840098,  948342276 },
        { 2141325313,  945133744, 2129965998 },
        { 2141317121, 1871100260, 1843844634 },
        { 2141286401, 1790639498, 1750465696 },
        { 2141267969, 1376858592,  186160720 },
        { 2141255681, 2129698296, 1876677959 },
        { 2141243393, 2138900688, 1340009628 },
        { 2141214721, 1933049835, 1087819477 },
        { 2141212673, 1898664939, 1786328049 },
        { 2141202433,  990234828,  940682169 },
        { 2141175809, 1406392421,  993089586 },
        { 2141165569, 1263518371,  289019479 },
        { 2141073409, 1485624211,  507864514 },
        { 2141052929, 1885134788,  311252465 },
        { 2141040641, 1285021247,  280941862 },
        { 2141028353, 1527610374,  375035110 },
        { 2141011969, 1400626168,  164696620 },
        { 2140999681,  632959608,  966175067 },
        { 2140997633, 2045628978, 1290889438 },
        { 2140993537, 1412755491,  375366253 },
        { 2140942337,  719477232,  785367828 },
        { 2140925953,   45224252,  836552317 },
        { 2140917761, 1157376588, 1001839569 },
        { 2140887041,  278480752, 2098732796 },
        { 2140837889, 1663139953,  924094810 },
        { 2140788737,  802501511, 2045368990 },
        { 2140766209, 1820083885, 1800295504 },
        { 2140764161, 1169561905, 2106792035 },
        { 2140696577,  127781498, 1885987531 },
        { 2140684289,   16014477, 1098116827 },
        { 2140653569,  665960598, 1796728247 },
        { 2140594177, 1043085491,  377310938 },
        { 2140579841, 1732838211, 1504505945 },
        { 2140569601,  302071939,  358291016 },
        { 2140567553,  192393733, 1909137143 },
        { 2140557313,  406595731, 1175330270 },
        { 2140549121, 1748850918,  525007007 },
        { 2140477441,  499436566, 1031159814 },
        { 2140469249, 1886004401, 1029951320 },
        { 2140426241, 1483168100, 1676273461 },
        { 2140420097, 1779917297,  846024476 },
        { 2140413953,  522948893, 1816354149 },
        { 2140383233, 1931364473, 1296921241 },
        { 2140366849, 1917356555,  147196204 },
        { 2140354561,   16466177, 1349052107 },
        { 2140348417, 1875366972, 1860485634 },
        { 2140323841,  456498717, 1790256483 },
        { 2140321793, 1629493973,  150031888 },
        { 2140315649, 1904063898,  395510935 },
        { 2140280833, 1784104328,  831417909 },
        { 2140250113,  256087139,  697349101 },
        { 2140229633,  388553070,  243875754 },
        { 2140223489,  747459608, 1396270850 },
        { 2140200961,  507423743, 1895572209 },
        { 2140162049,  580106016, 2045297469 },
        { 2140149761,  712426444,  785217995 },
        { 2140137473, 1441607584,  536866543 },
        { 2140119041,  346538902, 1740434653 },
        { 2140090369,  282642885,   21051094 },
        { 2140076033, 1407456228,  319910029 },
        { 2140047361, 1619330500, 1488632070 },
        { 2140041217, 2089408064, 2012026134 },
        { 2140008449, 1705524800, 1613440760 },
        { 2139924481, 1846208233, 1280649481 },
        { 2139906049,  989438755, 1185646076 },
        { 2139867137, 1522314850,  372783595 },
        { 2139842561, 1681587377,  216848235 },
        { 2139826177, 2066284988, 1784999464 },
        { 2139824129,  480888214, 1513323027 },
        { 2139789313,  847937200,  858192859 },
        { 2139783169, 1642000434, 1583261448 },
        { 2139770881,  940699589,  179702100 },
        { 2139768833,  315623242,  964612676 },
        { 2139666433,  331649203,  764666914 },
        { 2139641857, 2118730799, 1313764644 },
        { 2139635713,  519149027,  519212449 },
        { 2139598849, 1526413634, 1769667104 },
        { 2139574273,  551148610,  820739925 },
        { 2139568129, 1386800242,  472447405 },
        { 2139549697,  813760130, 1412328531 },
        { 2139537409, 1615286260, 1609362979 },
        { 2139475969, 1352559299, 1696720421 },
        { 2139455489, 1048691649, 1584935400 },
        { 2139432961,  836025845,  950121150 },
        { 2139424769, 1558281165, 1635486858 },
        { 2139406337, 1728402143, 1674423301 },
        { 2139396097, 1727715782, 1483470544 },
        { 2139383809, 1092853491, 1741699084 },
        { 2139369473,  690776899, 1242798709 },
        { 2139351041, 1768782380, 2120712049 },
        { 2139334657, 1739968247, 1427249225 },
        { 2139332609, 1547189119,  623011170 },
        { 2139310081, 1346827917, 1605466350 },
        { 2139303937,  369317948,  828392831 },
        { 2139301889, 1560417239, 1788073219 },
        { 2139283457, 1303121623,  595079358 },
        { 2139248641, 1354555286,  573424177 },
        { 2139240449,   60974056,  885781403 },
        { 2139222017,  355573421, 1221054839 },
        { 2139215873,  566477826, 1724006500 },
        { 2139150337,  871437673, 1609133294 },
        { 2139144193, 1478130914, 1137491905 },
        { 2139117569, 1854880922,  964728507 },
        { 2139076609,  202405335,  756508944 },
        { 2139062273, 1399715741,  884826059 },
        { 2139045889, 1051045798, 1202295476 },
        { 2139033601, 1707715206,  632234634 },
        { 2139006977, 2035853139,  231626690 },
        { 2138951681,  183867876,  838350879 },
        { 2138945537, 1403254661,  404460202 },
        { 2138920961,  310865011, 1282911681 },
        { 2138910721, 1328496553,  103472415 },
        { 2138904577,   78831681,  993513549 },
        { 2138902529, 1319697451, 1055904361 },
        { 2138816513,  384338872, 1706202469 },
        { 2138810369, 1084868275,  405677177 },
        { 2138787841,  401181788, 1964773901 },
        { 2138775553, 1850532988, 1247087473 },
        { 2138767361,  874261901, 1576073565 },
        { 2138757121, 1187474742,  993541415 },
        { 2138748929, 1782458888, 1043206483 },
        { 2138744833, 1221500487,  800141243 },
        { 2138738689,  413465368, 1450660558 },
        { 2138695681,  739045140,  342611472 },
        { 2138658817, 1355845756,  672674190 },
        { 2138644481,  608379162, 1538874380 },
        { 2138632193, 1444914034,  686911254 },
        { 2138607617,  484707818, 1435142134 },
        { 2138591233,  539460669, 1290458549 },
        { 2138572801, 2093538990, 2011138646 },
        { 2138552321, 1149786988, 1076414907 },
        { 2138546177,  840688206, 2108985273 },
        { 2138533889,  209669619,  198172413 },
        { 2138523649, 1975879426, 1277003968 },
        { 2138490881, 1351891144, 1976858109 },
        { 2138460161, 1817321013, 1979278293 },
        { 2138429441, 1950077177,  203441928 },
        { 2138400769,  908970113,  628395069 },
        { 2138398721,  219890864,  758486760 },
        { 2138376193, 1306654379,  977554090 },
        { 2138351617,  298822498, 2004708503 },
        { 2138337281,  441457816, 1049002108 },
        { 2138320897, 1517731724, 1442269609 },
        { 2138290177, 1355911197, 1647139103 },
        { 2138234881,  531313247, 1746591962 },
        { 2138214401, 1899410930,  781416444 },
        { 2138202113, 1813477173, 1622508515 },
        { 2138191873, 1086458299, 1025408615 },
        { 2138183681, 1998800427,  827063290 },
        { 2138173441, 1921308898,  749670117 },
        { 2138103809, 1620902804, 2126787647 },
        { 2138099713,  828647069, 1892961817 },
        { 2138085377,  179405355, 1525506535 },
        { 2138060801,  615683235, 1259580138 },
        { 2138044417, 2030277840, 1731266562 },
        { 2138042369, 2087222316, 1627902259 },
        { 2138032129,  126388712, 1108640984 },
        { 2138011649,  715026550, 1017980050 },
        { 2137993217, 1693714349, 1351778704 },
        { 2137888769, 1289762259, 1053090405 },
        { 2137853953,  199991890, 1254192789 },
        { 2137833473,  941421685,  896995556 },
        { 2137817089,  750416446, 1251031181 },
        { 2137792513,  798075119,  368077456 },
        { 2137786369,  878543495, 1035375025 },
        { 2137767937,    9351178, 1156563902 },
        { 2137755649, 1382297614, 1686559583 },
        { 2137724929, 1345472850, 1681096331 },
        { 2137704449,  834666929,  630551727 },
        { 2137673729, 1646165729, 1892091571 },
        { 2137620481,  778943821,   48456461 },
        { 2137618433, 1730837875, 1713336725 },
        { 2137581569,  805610339, 1378891359 },
        { 2137538561,  204342388, 1950165220 },
        { 2137526273, 1947629754, 1500789441 },
        { 2137516033,  719902645, 1499525372 },
        { 2137491457,  230451261,  556382829 },
        { 2137440257,  979573541,  412760291 },
        { 2137374721,  927841248, 1954137185 },
        { 2137362433, 1243778559,  861024672 },
        { 2137313281, 1341338501,  980638386 },
        { 2137311233,  937415182, 1793212117 },
        { 2137255937,  795331324, 1410253405 },
        { 2137243649,  150756339, 1966999887 },
        { 2137182209,  163346914, 1939301431 },
        { 2137171969, 1952552395,  758913141 },
        { 2137159681,  570788721,  218668666 },
        { 2137147393, 1896656810, 2045670345 },
        { 2137141249,  358493842,  518199643 },
        { 2137139201, 1505023029,  674695848 },
        { 2137133057,   27911103,  830956306 },
        { 2137122817,  439771337, 1555268614 },
        { 2137116673,  790988579, 1871449599 },
        { 2137110529,  432109234,  811805080 },
        { 2137102337, 1357900653, 1184997641 },
        { 2137098241,  515119035, 1715693095 },
        { 2137090049,  408575203, 2085660657 },
        { 2137085953, 2097793407, 1349626963 },
        { 2137055233, 1556739954, 1449960883 },
        { 2137030657, 1545758650, 1369303716 },
        { 2136987649,  332602570,  103875114 },
        { 2136969217, 1499989506, 1662964115 },
        { 2136924161,  857040753,    4738842 },
        { 2136895489, 1948872712,  570436091 },
        { 2136893441,   58969960, 1568349634 },
        { 2136887297, 2127193379,  273612548 },
        { 2136850433,  111208983, 1181257116 },
        { 2136809473, 1627275942, 1680317971 },
        { 2136764417, 1574888217,   14011331 },
        { 2136741889,   14011055, 1129154251 },
        { 2136727553,   35862563, 1838555253 },
        { 2136721409,  310235666, 1363928244 },
        { 2136698881, 1612429202, 1560383828 },
        { 2136649729, 1138540131,  800014364 },
        { 2136606721,  602323503, 1433096652 },
        { 2136563713,  182209265, 1919611038 },
        { 2136555521,  324156477,  165591039 },
        { 2136549377,  195513113,  217165345 },
        { 2136526849, 1050768046,  939647887 },
        { 2136508417, 1886286237, 1619926572 },
        { 2136477697,  609647664,   35065157 },
        { 2136471553,  679352216, 1452259468 },
        { 2136457217,  128630031,  824816521 },
        { 2136422401,   19787464, 1526049830 },
        { 2136420353,  698316836, 1530623527 },
        { 2136371201, 1651862373, 1804812805 },
        { 2136334337,  326596005,  336977082 },
        { 2136322049,   63253370, 1904972151 },
        { 2136297473,  312176076,  172182411 },
        { 2136248321,  381261841,  369032670 },
        { 2136242177,  358688773, 1640007994 },
        { 2136229889,  512677188,   75585225 },
        { 2136219649, 2095003250, 1970086149 },
        { 2136207361, 1909650722,  537760675 },
        { 2136176641, 1334616195, 1533487619 },
        { 2136158209, 2096285632, 1793285210 },
        { 2136143873, 1897347517,  293843959 },
        { 2136133633,  923586222, 1022655978 },
        { 2136096769, 1464868191, 1515074410 },
        { 2136094721, 2020679520, 2061636104 },
        { 2136076289,  290798503, 1814726809 },
        { 2136041473,  156415894, 1250757633 },
        { 2135996417,  297459940, 1132158924 },
        { 2135955457,  538755304, 1688831340 },
        { 0, 0, 0 }
};


DOUBLE gram_schmidt_norm(SINT32 *f, SINT32 *g, size_t n,
    SINT32 q, DOUBLE bd)
{
    // FIRST NORM
    // Don't bother creating the arrays with the correct signs,
    // the values are being squared so directly multiply-accumulate
    // the input f, g
    DOUBLE modx = 0;
    for (size_t i=n; i--;) {
        modx += f[i] * f[i] + g[i] * g[i];
    }
    modx = sqrt(modx);
#if DEBUG_GPV == 1
    fprintf(stderr, "||(g, -f)|| = %3.3f\n", modx);
#endif

    // Early termination - if ||(g,-f)|| cannot satisfy the condition
    // threshold then there's no point continuing, output the bad
    // Gram Schmidt norm and try again.
    if (modx > bd) {
        return modx;
    }


    size_t i;
#if 0
    // SECOND NORM
    // Floating-point precision is required
    DOUBLE *f2, *g2;
    f2 = SC_MALLOC(sizeof(DOUBLE) * 2 * n);
    g2 = f2 + n;
    sc_fft_t *ctx_fft = create_fft(n);
    SINT32 fb[n], gb[n];
    sc_complex_t f_fft[n], g_fft[n];
    sc_complex_t fb_fft[n], gb_fft[n];
    sc_complex_t F[n], G[n];

    fb[0] = f[0];
    for (i=1; i<n; i++) {
        fb[i] = -f[n-i];
    }
    gb[0] = g[0];
    for (i=1; i<n; i++) {
        gb[i] = -g[n-i];
    }

    fwd_fft_int(ctx_fft, f_fft, f);
    fwd_fft_int(ctx_fft, g_fft, g);
    fwd_fft_int(ctx_fft, fb_fft, fb);
    fwd_fft_int(ctx_fft, gb_fft, gb);

    for (i=0; i<n; i++) {
        sc_complex_t temp = f_fft[i]*fb_fft[i] + g_fft[i]*gb_fft[i];
        temp = 1 / temp;
        F[i] = fb_fft[i] * temp;
        G[i] = gb_fft[i] * temp;
    }
#else
    // SECOND NORM
    // Floating-point precision is required
    DOUBLE *f2, *g2;
    f2 = SC_MALLOC(sizeof(DOUBLE) * 2 * n);
    g2 = f2 + n;
    sc_fft_t *ctx_fft = create_fft(n);
    sc_complex_t *f_fft, *g_fft, *F, *G;
    f_fft = SC_MALLOC(sizeof(sc_complex_t) * 4 * n);
    g_fft = f_fft + n;
    F = g_fft + n;
    G = F + n;
    fwd_fft_int(ctx_fft, f_fft, f);
    fwd_fft_int(ctx_fft, g_fft, g);

    // This is an approximation
    for(i=0; i<n; i++) {
        sc_complex_t temp = f_fft[i]*f_fft[n-1-i] + g_fft[i]*g_fft[n-1-i];
        F[i] = f_fft[i] / temp;
        G[i] = g_fft[i] / temp;
    }

    SC_FREE(f_fft, sizeof(sc_complex_t) * 4 * n);
#endif

    inv_fft_dbl(ctx_fft, f2, F);
    inv_fft_dbl(ctx_fft, g2, G);
    destroy_fft(ctx_fft);

    DOUBLE b_N1 = 0;
    for(i=n; i--;) {
        b_N1 += f2[i] * f2[i] + g2[i] * g2[i];
    }
    b_N1 = (DOUBLE) q * sqrt(b_N1);

    SC_FREE(f2, sizeof(DOUBLE) * 2 * n);

    if (b_N1 < 0 || isnanl(b_N1)) {

        return 2*bd;
    }

#if DEBUG_GPV == 1
    fprintf(stderr, "||(qfb/(ggb + ffb), qgb/(ggb + ffb))|| = %3.9f\n", b_N1);
#endif
    if (modx > b_N1) {
        return modx;
    }
    else {
        return b_N1;
    }
}

static SINT32 poly_limb_anticirculant(const SINT32 *f, size_t n, SINT32 *mat_A)
{
    size_t i, j;

    SINT32 deg_f = poly_32_degree(f, n);
    if (-1 == deg_f || n <= (size_t)deg_f) {
        return SC_FUNC_FAILURE;
    }

    for (i=0; i<n; i++) {
        for (j=i; (j<=deg_f+i) && (j<n); j++) {
            mat_A[i*n+j] = f[j-i];
        }
        for (j=0; (j+n)<=(deg_f+i); j++) {
            mat_A[i*n+j] = -f[j-i+n];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gpv_expand_basis(const gpv_t *gpv)
{
    size_t i, j;
    size_t n = gpv->n;
    SINT32 *mat_A = SC_MALLOC(sizeof(SINT32) * n * n);
    if (NULL == mat_A) {
        return SC_FUNC_FAILURE;
    }

    /// @todo Modify the anticirculant function to avoid intermediate storage
    /// and data copying

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->g, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[i*2*n+j] = mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->f, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[i*2*n+j+n] = -mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->G, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[(i+n)*2*n+j] = mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->F, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[(i+n)*2*n+j+n] = -mat_A[i*n+j];
        }
    }

    SC_FREE(mat_A, sizeof(SINT32) * n * n);

    return SC_FUNC_SUCCESS;
}

SINT32 gpv_read_basis(const gpv_t *gpv, size_t row, size_t col)
{
    size_t n = gpv->n;
    SINT32 i = (SINT32)col - (SINT32)row;
    SINT32 p;
    size_t first = col < n;
    while (i < 0) i += n;
    while (i >= n) i -= n;
    p = (row < n)? (first)? gpv->g[i] : -gpv->f[i] :
                   (first)? gpv->G[i] : -gpv->F[i];
    if (col >= n) col -= n;
    if (row >= n) row -= n;
    return (col < row)? -p : p;
}

FLOAT dot(const SINT32 *x, const SINT32 *y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

FLOAT dot_flt(const FLOAT *x, const FLOAT *y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

DOUBLE dot_s32_dbl(const SINT32 * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const SINT32 *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

DOUBLE dot_s64_dbl(const SINT64 * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const SINT64 *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

FLOAT dot_s32_flt(const SINT32 * SC_RESTRICT x, const FLOAT * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const SINT32 *a = x + u*n;
    const FLOAT *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

FLOAT dot_s64_flt(const SINT64 * SC_RESTRICT x, const FLOAT * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const SINT64 *a = x + u*n;
    const FLOAT *b = y + v*n;

    for (k=n; k--;) {
        dot += (FLOAT)(*a++) * *b++;
    }

    return dot;
}

DOUBLE dot_dbl(const DOUBLE * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const DOUBLE *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

DOUBLE dot_sqr_dbl(const DOUBLE *x, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const DOUBLE *a = x + u*n;

    for (k=n; k--;) {
        dot += (*a) * (*a);
        a++;
    }

    return dot;
}

FLOAT dot_sqr_flt(const FLOAT *x, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const FLOAT *a = x + u*n;

    for (k=n; k--;) {
        dot += (*a) * (*a);
        a++;
    }

    return dot;
}

LONGDOUBLE dot_ldbl(const LONGDOUBLE *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0.0L;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

DOUBLE dot_ldbl_dbl(const LONGDOUBLE *x, const DOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    DOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (DOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

FLOAT dot_ldbl_flt(const LONGDOUBLE *x, const FLOAT *y, size_t n, size_t u, size_t v)
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += (FLOAT) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

LONGDOUBLE dot_s32_ldbl(const SINT32 *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (LONGDOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

LONGDOUBLE dot_s64_ldbl(const SINT64 *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (LONGDOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

void gpv_precompute_inv_ldbl(const LONGDOUBLE *b_gs, LONGDOUBLE *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        LONGDOUBLE sqr = dot_ldbl(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = 1.0 / sqrtl(sqr);
    }
}

void gpv_precompute_inv_dbl(const DOUBLE *b_gs, DOUBLE *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        DOUBLE sqr = dot_dbl(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = 1.0 / sqrt(sqr);
    }
}

void gpv_precompute_inv_flt(const FLOAT *b_gs, FLOAT *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        DOUBLE sqr = dot_flt(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = (FLOAT)(1.0 / sqrt(sqr));
    }
}

void modified_gram_schmidt_classical(const gpv_t *gpv, LONGDOUBLE *b_gs, SINT32 q)
{
    size_t i, j, k;
    size_t n = gpv->n;
    LONGDOUBLE inv_sq_norm[2*n], temp[2*n];

    inv_sq_norm[0] = 0;
    for (k=0; k<2*n; k++) {
        inv_sq_norm[0] += gpv->b[k] * gpv->b[k];
    }
    inv_sq_norm[0] = 1 / inv_sq_norm[0];

    for (j=0; j<2*n; j++) {
        b_gs[j] = gpv->b[j];
    }

    for (i=1; i<2*n; i++) {
        for (k=0; k<2*n; k++) {
            b_gs[i*2*n + k] = gpv->b[i*2*n + k];
        }

        for (j=0; j<i; j++) {
            temp[j] = dot_ldbl(b_gs, b_gs, 2*n, i, j) * inv_sq_norm[j];
        }

        for (k=0; k<2*n; k++) {
            for (j=0; j<i; j++) {
                b_gs[i*2*n + k] -= temp[j] * gpv->b[j*2*n + k];
            }
        }

        inv_sq_norm[i] = 1 / dot_ldbl(b_gs, b_gs, 2*n, i, i);
    }
}

void modified_gram_schmidt_fast_flt(const gpv_t *gpv,
    FLOAT *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    FLOAT v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    FLOAT C_k, D_k, D_k_inv;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_flt(b_gs, v, 2*n, 0, 0);
    D_k = dot_sqr_flt(v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        FLOAT aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        FLOAT C_ko = C_k;
        FLOAT D_ko = D_k;
        C_k = dot_flt(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    D_k_inv = 1 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (FLOAT)q * D_k_inv;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (FLOAT)q * D_k_inv;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_flt(b_gs, v1, 2*n, n, 0);
    D_k = dot_sqr_flt(b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        FLOAT aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        FLOAT C_ko = C_k;
        FLOAT D_ko = D_k;
        C_k = dot_flt(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

void modified_gram_schmidt_fast_dbl(const gpv_t *gpv,
    DOUBLE *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    DOUBLE v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    DOUBLE C_k, D_k;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_dbl(b_gs, v, 2*n, 0, 0);
    D_k = dot_sqr_dbl(v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        DOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        DOUBLE C_ko = C_k;
        DOUBLE D_ko = D_k;
        C_k = dot_dbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    DOUBLE inv_D_k = 1.0 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (DOUBLE)q * inv_D_k;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (DOUBLE)q * inv_D_k;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_dbl(b_gs, v1, 2*n, n, 0);
    D_k = dot_sqr_dbl(b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        DOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        DOUBLE C_ko = C_k;
        DOUBLE D_ko = D_k;
        C_k = dot_dbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

void modified_gram_schmidt_fast_ldbl(const gpv_t *gpv,
    LONGDOUBLE *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    LONGDOUBLE v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    LONGDOUBLE C_k, D_k;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_ldbl(b_gs, v, 2*n, 0, 0);
    D_k = dot_ldbl(v, v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        LONGDOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        LONGDOUBLE C_ko = C_k;
        LONGDOUBLE D_ko = D_k;
        C_k = dot_ldbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    LONGDOUBLE D_k_inv = 1 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (LONGDOUBLE)q * D_k_inv;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (LONGDOUBLE)q * D_k_inv;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_ldbl(b_gs, v1, 2*n, n, 0);
    D_k = dot_ldbl(b_gs, b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        LONGDOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        LONGDOUBLE C_ko = C_k;
        LONGDOUBLE D_ko = D_k;
        C_k = dot_ldbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

static const size_t MAX_BL_SMALL2[] = {
    1, 1, 2, 2, 4, 7, 14, 27, 53, 106, 212
};

static const size_t MAX_BL_LARGE2[] = {
    2, 2, 5, 7, 12, 22, 42, 80, 157, 310
};

static UINT32 set_mod(UINT32 x, UINT32 p)
{
    x -= p;
    x += p & -(x >> 31);
    return x;
}

static UINT32 add_mod(UINT32 x, UINT32 y, UINT32 p)
{
    x += y - p;
    x += p & -(x >> 31);
    return x;
}

static UINT32 sub_mod(UINT32 x, UINT32 y, UINT32 p)
{
    x -= y;
    x += p & -(x >> 31);
    return x;
}

static UINT32 bigint_mod_u32(const UINT32 *d, size_t dlen,
    const utils_arith_ntt_t *sc_ntt, const ntt_params_t *ntt_p)
{
    UINT32 x, p;
    size_t i;
    p = ntt_p->u.ntt32.q;

    // Algorithm: we inject words one by one, starting with the high
    // word. Each step is:
    //  - multiply x by 2^31
    //  - add new word
    x = 0;
    i = dlen;
    while (i--) {
        UINT32 w;

        x = sc_ntt->muln_32(x, 0x40000000, ntt_p);
        w = set_mod(d[i], p);
        w = add_mod(x, w, p);
    }
    return x;
}

static UINT32 bigint_mod_s32(const UINT32 *d, size_t dlen, UINT32 rexp,
    const utils_arith_ntt_t *sc_ntt, const ntt_params_t *ntt_p)
{
    UINT32 x, p;
    size_t i;

    if (0 == dlen) {
        return 0;
    }

    p = ntt_p->u.ntt32.q;
    x = bigint_mod_u32(d, dlen, sc_ntt, ntt_p);
    x = sub_mod(x, rexp & -(d[dlen-1] >> 30), p);
    return x;
}

static void bigint_add_mul_small(UINT32 *restrict x,
        const UINT32 *restrict y, size_t len, UINT32 s)
{
    size_t u;
    UINT32 cc;

    cc = 0;
    for (u = 0; u < len; u ++) {
        UINT32 xw, yw;
        UINT64 z;

        xw = x[u];
        yw = y[u];
        z = (UINT64)yw * (UINT64)s + (UINT64)xw + (UINT64)cc;
        x[u] = (UINT32)z & 0x7FFFFFFF;
        cc = (UINT32)(z >> 31);
    }
    x[len] = cc;
}

static UINT32 bigint_mul_small(UINT32 *m, size_t mlen, UINT32 x)
{
        size_t u;
        UINT32 cc;

        cc = 0;
        for (u = 0; u < mlen; u ++) {
                UINT64 z;

                z = (UINT64)m[u] * (UINT64)x + cc;
                m[u] = (UINT32)z & 0x7FFFFFFF;
                cc = (UINT32)(z >> 31);
        }
        return cc;
}

static uint32_t bigint_sub(UINT32 *restrict a, const UINT32 *restrict b, size_t len)
{
    size_t u;
    UINT32 cc;

    cc = 0;
    for (u = 0; u < len; u ++) {
        UINT32 w;

        w = a[u] - b[u] - cc;
        a[u] = w & 0x7FFFFFFF;
        cc = w >> 31;
    }
    return cc;
}

static void bigint_norm_zero(UINT32 *restrict x, const UINT32 *restrict p, size_t len)
{
    UINT32 cc;
    size_t u;

    cc = 0;
    u = len;
    while (u -- > 0) {
        UINT32 w;

        w = (p[u] >> 1) | (cc << 30);
        cc = p[u] & 1;
        if (x[u] < w) {
            return;
        }
        if (x[u] > w) {
            bigint_sub(x, p, len);
            return;
        }
    }
}

// Use CRT to convert a number in residue number system representation consisting of n integers
// each of len words into a little-endian multi-word integer. Each adjacent integer is accessed
// using the offset. Normalize is used to normalize to (-m/2 to m/2).
void rns_to_integer(UINT32 *inout, size_t len, size_t offset, size_t n,
    const utils_arith_ntt_t *sc_ntt, SINT32 normalize, UINT32 *temp)
{
    size_t i, j;
    UINT32 *x;

    // Iterate over the len words of all n integers
    for (i=1; i<len; i++) {
        ntt_params_t ntt_p;
        UINT32 s, p;

        s = binary_primes[i].s;
        p = binary_primes[i].p;

        init_reduce(&ntt_p, n, p);

        // Iterate over the n integers
        for (j=0, x=inout; j<n; j++, x+=offset) {
            UINT32 xp, xq, xr;
            xp = x[i];
            xq = bigint_mod_u32(x, i, sc_ntt, &ntt_p);

            // Calculate (xp - xq) mod p
            xp = xp - xq;
            xp += p & -(xp >> 31);

            // xr = s * (xp - xq) mod p
            xr = sc_ntt->muln_32(s, xp, &ntt_p);

            bigint_add_mul_small(x, temp, i, xr);
        }

        temp[i] = bigint_mul_small(temp, i, p);
    }

    if (normalize) {
        for (i=0, x=inout; i<n; i++, x+=offset) {
            bigint_norm_zero(x, temp, len);
        }
    }
}

static void fg_step_mul(UINT32 *d, UINT32 *s, UINT32 prime, size_t idx, size_t n, size_t logn,
    size_t slen, size_t tlen, UINT32 *temp, SINT32 ntt_flag, SINT32 *ntt_w, SINT32 *ntt_r,
    const utils_arith_ntt_t *sc_ntt, const ntt_params_t *ntt_logn)
{
    size_t v, hn;
    UINT32 *x;

    hn = n >> 1;

    for (v=0, x=s+idx; v<n; v++, x+=slen) {
        temp[v] = *x;
    }

    if (!ntt_flag) {
        sc_ntt->fwd_ntt_32_32(temp, ntt_logn, temp, ntt_w);
    }

    for (v=0, x=d+idx; v<hn; v++, x+=tlen) {
        UINT32 w0, w1;
        w0 = temp[(v<<1) + 0];
        w1 = temp[(v<<1) + 1];
        *x = sc_ntt->muln_32(sc_ntt->muln_32(w0, w1, ntt_logn), 0x40000000, ntt_logn);
    }

    if (ntt_flag) {
        for (v=0, x=s+idx; v<n; v++, x+=slen) {
           temp[v] = *x;
        }
        sc_ntt->inv_ntt_32_32(temp, ntt_logn, temp, ntt_w, ntt_r);
        for (v=0, x=s+idx; v<n; v++, x+=slen) {
           *x = temp[v];
        }
    }
}

static void fg_step_mul2(UINT32 *d, UINT32 *s, UINT32 prime, UINT32 rexp, size_t idx, size_t n, size_t logn,
    size_t slen, size_t tlen, UINT32 *temp, SINT32 ntt_flag, SINT32 *ntt_w, SINT32 *ntt_r,
    const utils_arith_ntt_t *sc_ntt, const ntt_params_t *ntt_logn)
{
    size_t v, hn;
    UINT32 *x;
    UINT32 p;

    hn = n >> 1;
    p = binary_primes[idx].p;

    for (v=0, x=s+idx; v<n; v++, x+=slen) {
        temp[v] = bigint_mod_s32(x, slen, rexp, sc_ntt, ntt_logn);
    }

    sc_ntt->fwd_ntt_32_32(temp, ntt_logn, temp, ntt_w);

    for (v=0, x=d+idx; v<hn; v++, x+=tlen) {
        UINT32 w0, w1;
        w0 = temp[(v<<1) + 0];
        w1 = temp[(v<<1) + 1];
        *x = sc_ntt->muln_32(sc_ntt->muln_32(w0, w1, ntt_logn), 0x40000000, ntt_logn);
    }
}

// Calculate 2^(31*x) modulo p
UINT32 exp_modp(UINT32 x, UINT32 p, const utils_arith_ntt_t *sc_ntt, ntt_params_t *ntt_p)
{
    size_t i;
    UINT32 y = (1<<31) - p;  // i.e. As 2^30 < p < 2^31, 2^31 mod p = 2^31 - p
    for (i=0; (1<<i)<=x; i++) {
        if (0 != (x & (1<<i))) {
            y = sc_ntt->muln_32(x, y, ntt_p);
        }
        y = sc_ntt->muln_32(y, y, ntt_p);
    }
    return y;
}

void ntru_make_fg_step(UINT32 *out, size_t logn, size_t depth, UINT32 q,
    SINT32 in_ntt_flag, SINT32 out_ntt_flag,
    const utils_arith_ntt_t *sc_ntt)
{
    UINT32 *fd, *gd, *fs, *gs;
    SINT32 *ntt_w, *ntt_r, *t;
    size_t i, j, n, slen, tlen;

    // Compute the degree, destination length and source length
    n    = 1 << logn;
    slen = MAX_BL_SMALL2[depth];
    tlen = MAX_BL_SMALL2[depth + 1];

    // Assign memory pointers for the output (f',g'), step input (fs,gs), NTT LUT's (gm,igm)
    // and a scratch array t
    fd    = out;
    gd    = fd + (n >> 1) * tlen;
    fs    = gd + (n >> 1) * tlen;
    gs    = fs + n * slen;
    ntt_w = (SINT32*)(gs + n * slen);
    ntt_r = (SINT32*)(ntt_w + n);
    t     = (UINT32*)(ntt_r + n);

    // Copy the previous output to the intermediate input (fs,gs) with an overlapping copy
    memmove(fs, fd, 2 * n * slen * sizeof(UINT32));

    // 
    for (i=0; i<slen; i++) {
        ntt_params_t ntt_p;

        // Pick a prime number and calculate the NTT LUT coefficients
        UINT32 prime, prime_root;
        prime      = binary_primes[i].p;
        prime_root = binary_primes[i].g;
        roots_of_unity_s32(ntt_w, ntt_r, n, prime, prime_root);

        init_reduce(&ntt_p, n, prime);

        // Multiply of fs modulo a prime number to form fd
        fg_step_mul(fd, fs, prime, i, n, logn, slen, tlen, t, in_ntt_flag, ntt_w, ntt_r, sc_ntt, &ntt_p);

        // Multiply of gs modulo a prime number to form gd
        fg_step_mul(gd, gs, prime, i, n, logn, slen, tlen, t, in_ntt_flag, ntt_w, ntt_r, sc_ntt, &ntt_p);

        if (!out_ntt_flag) {
            UINT32 *x;
            ntt_p.n = n >> 1;

            for (j=0, x=fd+i; j<ntt_p.n; j++, x+=tlen) {
                t[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(t, &ntt_p, t, ntt_w, ntt_r);
            for (j=0, x=fd+i; j<ntt_p.n; j++, x+=tlen) {
                *x = t[j];
            }

            for (j=0, x=gd+i; j<ntt_p.n; j++, x+=tlen) {
                t[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(t, &ntt_p, t, ntt_w, ntt_r);
            for (j=0, x=gd+i; j<ntt_p.n; j++, x+=tlen) {
                *x = t[j];
            }
        }
    }

    // Use CRT to rebuild the fs and gs values from the residue number system
    rns_to_integer(fs, slen, slen, n, sc_ntt, 1, t);
    rns_to_integer(gs, slen, slen, n, sc_ntt, 1, t);

    // Use modular reduction to obtain the output values
    for (i=slen; i<tlen; i++) {
        ntt_params_t ntt_p;

        // Pick a prime number and calculate the NTT LUT coefficients
        UINT32 prime, prime_root, rexp;
        prime      = binary_primes[i].p;
        prime_root = binary_primes[i].g;
        roots_of_unity_s32(ntt_w, ntt_r, n, prime, prime_root);

        init_reduce(&ntt_p, n, prime);

        // Calculate the ring modulo the small prime number, 2^(31*slen) modulo p
        rexp = exp_modp(slen, prime, sc_ntt, &ntt_p);

        // Multiply of fs modulo a prime number to form fd
        fg_step_mul2(fd, fs, prime, rexp, i, n, logn, slen, tlen, t, in_ntt_flag, ntt_w, ntt_r, sc_ntt, &ntt_p);

        // Multiply of gs modulo a prime number to form gd
        fg_step_mul2(gd, gs, prime, rexp, i, n, logn, slen, tlen, t, in_ntt_flag, ntt_w, ntt_r, sc_ntt, &ntt_p);

        if (!out_ntt_flag) {
            UINT32 *x;
            ntt_p.n = n >> 1;

            for (j=0, x=fd+i; j<ntt_p.n; j++, x+=tlen) {
                t[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(t, &ntt_p, t, ntt_w, ntt_r);
            for (j=0, x=fd+i; j<ntt_p.n; j++, x+=tlen) {
                *x = t[j];
            }

            for (j=0, x=gd+i; j<ntt_p.n; j++, x+=tlen) {
                t[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(t, &ntt_p, t, ntt_w, ntt_r);
            for (j=0, x=gd+i; j<ntt_p.n; j++, x+=tlen) {
                *x = t[j];
            }
        }
    }
}

void ntru_make_fg(UINT32 *out, SINT32 *f, SINT32 *g, size_t logn, size_t depth, UINT32 q, SINT32 out_ntt_flag,
    const utils_arith_ntt_t *sc_ntt)
{
    ntt_params_t ntt_params;
    UINT32 *ft, *gt, p0;
    size_t i, n = 1 << logn;

    ft = out;
    gt = ft + n;

    // Reduce the input (f,g) using the first prime
    p0 = binary_primes[0].p;
    init_reduce(&ntt_params, n, p0);
    for (i=0; i<n; i++) {
        ft[i] = sc_ntt->modn_32(f[i], &ntt_params);
        gt[i] = sc_ntt->modn_32(g[i], &ntt_params);
    }

    // Iteratively reduce (f,g) to (f',g')
    for (i=0; i<depth; i++) {
        ntru_make_fg_step(out, logn - i, i, q, i != 0, (i+1) < depth || out_ntt_flag, sc_ntt);
    }
}

// Repeatedly use the field norm to map (f,g) to a smaller ring Z[x]/(x^(n/2) + 1) until
// we reach the ring Z. We then compute the GCD of the (f,g) integers and use the multiplicative
// properties of the field norm to lift up to Z[x]/(x^n + 1).
SINT32 ntru_solve_step1(SINT32 *f, SINT32 *g, SINT32 *temp, UINT32 q, size_t logn)
{
    SINT32 retval = SC_FUNC_FAILURE;
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);

    size_t i, len = MAX_BL_SMALL2[logn];
    UINT32 *f_tmp, *g_tmp, *F_tmp, *G_tmp, *t;
    sc_mpz_t gcd, mp_f, mp_g, mp_F, mp_G;

    F_tmp = temp;
    G_tmp = F_tmp + len;
    f_tmp = G_tmp + len;
    g_tmp = f_tmp + len;
    t     = g_tmp + len;

    sc_mpz_init(&gcd);
    sc_mpz_init(&mp_f);
    sc_mpz_init(&mp_g);
    sc_mpz_init(&mp_F);
    sc_mpz_init(&mp_G);

    // Reduce (f,g) to integers using the field norm N
    ntru_make_fg(f_tmp, f, g, logn, logn, q, 0, sc_ntt);

    // Use CRT to convert the resultants into f' and g'
    rns_to_integer(f_tmp, len, len, 2, sc_ntt, 0, t);

    // Convert to a limb array
    sc_mpz_set_u32(&mp_f, f_tmp, len);
    sc_mpz_set_u32(&mp_g, g_tmp, len);

    // Compute the extended GCD of (f,g) such that uf - vg = gcd(f,g), ensuring that the
    // GCD is 1
    sc_mpz_xgcd(&mp_f, &mp_g, &gcd, &mp_F, &mp_G);
    if (1 != sc_mpz_get_ui(&gcd)) {
        goto finish;
    }

    // Scale f and g using the Bezout coefficients u and v, i.e. F = vq and G = uq
    sc_mpz_mul_ui(&mp_F, &mp_F, q);
    sc_mpz_mul_ui(&mp_G, &mp_G, q);
    sc_mpz_get_u32(F_tmp, &mp_F, len);
    sc_mpz_get_u32(G_tmp, &mp_G, len);

    retval = SC_FUNC_SUCCESS;

finish:
    sc_mpz_clear(&gcd);
    sc_mpz_clear(&mp_f);
    sc_mpz_clear(&mp_g);
    sc_mpz_clear(&mp_F);
    sc_mpz_clear(&mp_G);

    return retval;
}

SINT32 ntru_solve_step2_general(SINT32 *f, SINT32 *g, SINT32 *temp, UINT32 q, size_t logn, size_t depth)
{
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);

    SINT32 retval = SC_FUNC_FAILURE;
    size_t i, j, slen, dlen, llen, lift_logn, n, hn;
    UINT32 *Fd, *Gd, *ft, *gt, *Ft, *Gt, *t;

    lift_logn = logn - depth;
    n         = 1 << lift_logn;
    hn        = n >> 1;

    // slen = size for our input f and g; also size of the reduced
    //        F and G we return (degree N)
    //
    // dlen = size of the F and G obtained from the deeper level
    //
    // llen = size for intermediary F and G before reduction (degree N)
    //
    // We build our non-reduced F and G as two independent halves each,
    // of degree N/2 (F = F0 + X*F1, G = G0 + X*G1).
    slen = MAX_BL_SMALL2[depth];
    dlen = MAX_BL_SMALL2[depth + 1];
    llen = MAX_BL_LARGE2[depth];

    // Obtain f and g for the specified depth in RNS NTT format
    ft = temp + 2 * dlen * hn;
    ntru_make_fg(ft, f, g, logn, depth, q, 1, sc_ntt);

    // These are the inputs from the previous level
    Ft = temp;
    Gt = Ft + n * llen;

    // Move (f,g) to accommodate (F,G)
    t  = Gt + n * llen;
    memmove(t, ft, 2 * n * slen * sizeof(UINT32));
    ft = t;
    gt = ft + slen * n;
    t  = gt + slen * n;

    // Move (Fd,Gd) after (ft,gt)
    memmove(t, temp, 2 * hn * dlen * sizeof(UINT32));
    Fd = t;
    Gd = Fd + dlen * hn;

    // Reduce Fd and Gd modulo all the small primes of the RNS
    for (i=0; i<llen; i++) {
        ntt_params_t ntt_p;
        UINT32 *xs, *ys, *xd, *yd, prime, rexp;

        prime = binary_primes[i].p;
        init_reduce(&ntt_p, dlen, prime);

        // Calculate the ring modulo the small prime number, 2^(31*dlen) modulo prime
        rexp = exp_modp(dlen, prime, sc_ntt, &ntt_p);

        for (j=0, xs=Fd, ys=Gd, xd=Ft, yd=Gt; j<hn; j++, xs+=dlen, ys+=dlen, xd+=llen, yd+=llen) {
            *xd = bigint_mod_s32(xs, dlen, rexp, sc_ntt, &ntt_p);
            *yd = bigint_mod_s32(ys, dlen, rexp, sc_ntt, &ntt_p);
        }
    }

    // Compute F and G modulo the small primes
    for (i=0; i<llen; i++) {
        ntt_params_t ntt_p;
        UINT32 *fx, *gx, *Fp, *Gp, *s;
        UINT32 *x, *y;
        SINT32 *ntt_w, *ntt_r;
        UINT32 prime, prime_root;

        // Obtain the prime number and the NTT parameters
        prime      = binary_primes[i].p;
        prime_root = binary_primes[i].g;
        init_reduce(&ntt_p, llen, prime);

        ntt_w = (SINT32*) t;
        ntt_r = (SINT32*)(ntt_w + n);
        fx    = (UINT32*)(ntt_r + n);
        gx    = fx + n;
        s     = gx + n;
        roots_of_unity_s32(ntt_w, ntt_r, n, prime, prime_root);

        // When this point is reached f and g can be rebuilt from their non-NTT form
        if (i == slen) {
            rns_to_integer(ft, slen, slen, n, sc_ntt, 1, t);
            rns_to_integer(gt, slen, slen, n, sc_ntt, 1, t);
        }

        if (i < slen) {
            for (j=0, x=ft+i, y=gt+i; j<n; j++, x+=slen, y+=slen) {
                fx[j] = *x;
                gx[j] = *y;
            }

            // Inverse NTT of ft+i with a stride of slen
            for (j=0, x=ft+i; j<n; j++, x+=slen) {
                s[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(s, &ntt_p, s, ntt_w, ntt_r);
            for (j=0, x=ft+i; j<n; j++, x+=slen) {
                *x = s[j];
            }

            // Inverse NTT of gt+i with a stride of slen
            for (j=0, x=gt+i; j<n; j++, x+=slen) {
                s[j] = *x;
            }
            sc_ntt->inv_ntt_32_32(s, &ntt_p, s, ntt_w, ntt_r);
            for (j=0, x=gt+i; j<n; j++, x+=slen) {
                *x = s[j];
            }
        }
        else {
            UINT32 rexp;

            // Calculate the ring modulo the small prime number, 2^(31*dlen) modulo prime
            rexp = exp_modp(slen, prime, sc_ntt, &ntt_p);

            for (j=0, x=ft, y=gt; j<n; j++, x+=slen, y+=slen) {
                fx[j] = bigint_mod_s32(x, slen, rexp, sc_ntt, &ntt_p);
                gx[j] = bigint_mod_s32(y, slen, rexp, sc_ntt, &ntt_p);
            }

            sc_ntt->fwd_ntt_32_32(fx, &ntt_p, fx, ntt_w);
            sc_ntt->fwd_ntt_32_32(gx, &ntt_p, gx, ntt_w);
        }

        Fp = gx + n;
        Gp = Fp + hn;
        for (j=0, x=Ft+i, y=Gt+i; j<hn; j++, x+=llen, y+=llen) {
            Fp[j] = *x;
            Gp[j] = *y;
        }
        ntt_p.n >>= 1;
        sc_ntt->fwd_ntt_32_32(Fp, &ntt_p, Fp, ntt_w);
        sc_ntt->fwd_ntt_32_32(Gp, &ntt_p, Gp, ntt_w);


        // Compute F and G modulo p
        for (j=0, x=Ft+i, y=Gt+i; j<hn; j++, x+=(llen<<1), y+=(llen<<1)) {
            UINT32 ftA, ftB, gtA, gtB;

            ftA = fx[(j<<1)  ];
            ftB = fx[(j<<1)+1];
            gtA = gx[(j<<1)  ];
            gtB = gx[(j<<1)+1];
            x[0]    = sc_ntt->muln_32(Fp[j], gtB, &ntt_p);
            x[llen] = sc_ntt->muln_32(Fp[j], gtA, &ntt_p);
            y[0]    = sc_ntt->muln_32(Gp[j], ftB, &ntt_p);
            y[llen] = sc_ntt->muln_32(Gp[j], ftA, &ntt_p);
        }

        ntt_p.n <<= 1;

        // Inverse NTT of Ft+i with a stride of slen
        for (j=0, x=Ft+i; j<n; j++, x+=llen) {
            s[j] = *x;
        }
        sc_ntt->inv_ntt_32_32(s, &ntt_p, s, ntt_w, ntt_r);
        for (j=0, x=Ft+i; j<n; j++, x+=slen) {
            *x = s[j];
        }

        // Inverse NTT of Gt+i with a stride of slen
        for (j=0, x=Gt+i; j<n; j++, x+=llen) {
            s[j] = *x;
        }
        sc_ntt->inv_ntt_32_32(s, &ntt_p, s, ntt_w, ntt_r);
        for (j=0, x=Gt+i; j<n; j++, x+=slen) {
            *x = s[j];
        }
    }

    // Rebuild F and G using CRT
    rns_to_integer(Ft, llen, llen, n, sc_ntt, 1, t);
    rns_to_integer(Gt, llen, llen, n, sc_ntt, 1, t);

    // Babai reduction to bring F and G to size slen words at most

    retval = SC_FUNC_SUCCESS;

    return retval;
}

SINT32 ntru_solve_step2_1(SINT32 *f, SINT32 *g, SINT32 *temp, UINT32 q)
{
    SINT32 retval = SC_FUNC_FAILURE;

    retval = SC_FUNC_SUCCESS;

    return retval;
}

SINT32 ntru_solve_step2_0(SINT32 *f, SINT32 *g, SINT32 *temp, UINT32 q)
{
    SINT32 retval = SC_FUNC_FAILURE;

    retval = SC_FUNC_SUCCESS;

    return retval;
}

static size_t temp_size(unsigned logn)
{
#define ALIGN_FP(tt)   ((((tt) + sizeof(DOUBLE) - 1) / sizeof(DOUBLE)) * sizeof(DOUBLE))
#define ALIGN_UW(tt)   ((((tt) + sizeof(UINT32) - 1) \
                       / sizeof(UINT32)) * sizeof(UINT32))

    size_t gmax, depth;

    gmax = 0;

    // Compute memory requirements for make_fg() at each depth.
    for (depth = 0; depth < logn; depth ++) {
        size_t cur;
        size_t n, slen, tlen;

        n = (size_t)1 << (logn - depth);
        slen = MAX_BL_SMALL2[depth];
        tlen = MAX_BL_SMALL2[depth + 1];
        cur = (n * tlen + 2 * n * slen + 3 * n) * sizeof(UINT32);
        gmax = cur > gmax ? cur : gmax;
        cur = (n * tlen + 2 * n * slen + slen) * sizeof(UINT32);
        gmax = cur > gmax ? cur : gmax;
    }

    // Compute memory requirements for each depth.
    for (depth = 0; depth <= logn; depth ++) {
        size_t cur, max;

        max = 0;
        if (depth == logn) {
            size_t slen;

            slen = MAX_BL_SMALL2[depth];
            cur = 8 * slen * sizeof(UINT32);
            max = cur > max ? cur : max;
        } else if (depth == 0 && logn > 2) {
            size_t n, hn;

            n = (size_t)1 << logn;
            hn = n >> 1;
            cur = 7 * n * sizeof(UINT32);
            max = cur > max ? cur : max;
            cur = ALIGN_FP(4 * n * sizeof(UINT32)) + n * sizeof(DOUBLE);
            max = cur > max ? cur : max;
            cur = ALIGN_FP(3 * n * sizeof(UINT32)) + (n + hn) * sizeof(DOUBLE);
            max = cur > max ? cur : max;
        } else if (depth == 1 && logn > 2) {
            size_t n, hn, slen, dlen, llen;

            n = (size_t)1 << (logn - 1);
            hn = n >> 1;
            slen = MAX_BL_SMALL2[depth];
            dlen = MAX_BL_SMALL2[depth + 1];
            llen = MAX_BL_LARGE2[depth];
            cur = (2 * hn * dlen + 2 * n * llen) * sizeof(UINT32);
            max = cur > max ? cur : max;
            cur = (2 * n * llen + 2 * n * slen + 7 * n) * sizeof(UINT32);
            max = cur > max ? cur : max;
            cur = (2 * n * llen + 2 * n * slen + llen) * sizeof(UINT32);
            max = cur > max ? cur : max;
            cur = ALIGN_FP((2 * n * llen + 2 * n * slen) * sizeof(UINT32)) + 2 * n * sizeof(DOUBLE);
            max = cur > max ? cur : max;
            cur = ALIGN_FP(2 * n * slen * sizeof(UINT32)) + 4 * n * sizeof(DOUBLE);
            max = cur > max ? cur : max;
            cur = (5 * n + hn) * sizeof(DOUBLE);
            cur = ALIGN_FP(2 * n * sizeof(UINT32)) + 2 * n * sizeof(DOUBLE);
            max = cur > max ? cur : max;
        } else {
            size_t n, hn, slen, llen, tmp1, tmp2;

            n = (size_t)1 << (logn - depth);
            hn = n >> 1;
            slen = MAX_BL_SMALL2[depth];
            llen = MAX_BL_LARGE2[depth];
            cur = (2 * n * llen + 2 * n * slen + 4 * n) * sizeof(UINT32);
            max = cur > max ? cur : max;
            cur = (2 * n * llen + 2 * n * slen + llen) * sizeof(UINT32);
            max = cur > max ? cur : max;
            tmp1 = ALIGN_UW(
                    ALIGN_FP((2 * n * llen + 2 * n * slen) * sizeof(UINT32))
                    + (2 * n + hn) * sizeof(DOUBLE))
                    + n * sizeof(UINT32);
            tmp2 = ALIGN_FP((2 * n * llen + 2 * n * slen) * sizeof(UINT32))
                    + (3 * n + hn) * sizeof(DOUBLE);
            cur = tmp1 > tmp2 ? tmp1 : tmp2;
            cur = ALIGN_FP(cur) + n * sizeof(DOUBLE);
            max = cur > max ? cur : max;
            cur = ALIGN_UW(
                    ALIGN_FP((2 * n * llen + 2 * n * slen) * sizeof(UINT32))
                    + (2 * n + hn) * sizeof(DOUBLE))
                    + (5 * n + n * slen) * sizeof(UINT32);
            max = cur > max ? cur : max;
        }

        gmax = max > gmax ? max : gmax;
    }

    return gmax;

#undef ALIGN_FP
#undef ALIGN_UW
}

SINT32 field_norm_ntru_solve(SINT32 *f, SINT32 *g, SINT32 *F, SINT32 *G,
    UINT32 q, size_t logn)
{
    size_t len = temp_size(logn);
    SINT32 *temp = SC_MALLOC(len);

    if (SC_FUNC_SUCCESS != ntru_solve_step1(f, g, temp, q, logn)) {
        return SC_FUNC_FAILURE;
    }

    if (logn <= 2) {
        size_t d = logn;
        while (d--) {
            if (SC_FUNC_SUCCESS != ntru_solve_step2_general(f, g, temp, q, logn, d)) {
                return SC_FUNC_FAILURE;
            }
        }
    }
    else {
        size_t d = logn;
        while (d-- > 2) {
            if (SC_FUNC_SUCCESS != ntru_solve_step2_general(f, g, temp, q, logn, d)) {
                return SC_FUNC_FAILURE;
            }
        }

        if (SC_FUNC_SUCCESS != ntru_solve_step2_1(f, g, temp, q)) {
            return SC_FUNC_FAILURE;
        }
        if (SC_FUNC_SUCCESS != ntru_solve_step2_0(f, g, temp, q)) {
            return SC_FUNC_FAILURE;
        }
    }

    // Generate the output F and G polynomials

    SC_FREE(temp, len);

    return SC_FUNC_SUCCESS;
}

static SINT32 verify_private_key_32(safecrypto_t *sc, const SINT32 *f, const SINT32 *g,
    const SINT32 *F, const SINT32 *G, UINT32 q, size_t n,
    const SINT32 *ntt_w, const SINT32 *ntt_r, const ntt_params_t *ntt_params)
{
    // Verify that the NTRU equation is solved, i.e. f*G - g*F = q

    size_t i;
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    const utils_arith_poly_t *sc_poly  = sc->sc_poly;
    SINT32 *fn, *gn, *Fn, *Gn, *temp;
    UINT32 verify;
    SINT32 retval = SC_FUNC_FAILURE;

    temp = SC_MALLOC(sizeof(SINT32) * n * 3);
    fn = temp;
    gn = temp + n;
    Fn = temp + 2*n;
    Gn = temp + 2*n;

    // Calculate fG
    sc_ntt->fwd_ntt_32_32(fn, ntt_params, f, ntt_w);
    sc_ntt->fwd_ntt_32_32(Gn, ntt_params, G, ntt_w);
    sc_ntt->mul_32_pointwise(fn, ntt_params, fn, Gn);

    // Calculate gF
    sc_ntt->fwd_ntt_32_32(gn, ntt_params, g, ntt_w);
    sc_ntt->fwd_ntt_32_32(Fn, ntt_params, F, ntt_w);
    sc_ntt->mul_32_pointwise(gn, ntt_params, gn, Fn);

    // Calculate fG - gF
    sc_poly->sub_32(gn, n, fn, gn);
    sc_ntt->normalize_32(gn, n, ntt_params);

    // Verify that fG - gF = q = 0 mod q
    for (i=0; i<n; i++) {
        if (0 != gn[i]) {
            goto finish;
        }
    }

    retval = SC_FUNC_SUCCESS;

finish:
    SC_FREE(temp, sizeof(SINT32) * n * 3);
    return retval;
}

static SINT32 verify_private_key_16(safecrypto_t *sc, const SINT32 *f, const SINT32 *g,
    const SINT32 *F, const SINT32 *G, UINT32 q, size_t n,
    const SINT16 *ntt_w, const SINT16 *ntt_r, const ntt_params_t *ntt_params)
{
    // Verify that the NTRU equation is solved, i.e. f*G - g*F = q

    size_t i;
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    const utils_arith_poly_t *sc_poly  = sc->sc_poly;
    SINT32 *fn, *gn, *Fn, *Gn, *temp;
    UINT32 verify;
    SINT32 retval = SC_FUNC_FAILURE;

    temp = SC_MALLOC(sizeof(SINT32) * n * 3);
    fn = temp;
    gn = temp + n;
    Fn = temp + 2*n;
    Gn = temp + 2*n;

    // Calculate fG
    sc_ntt->fwd_ntt_32_16(fn, ntt_params, f, ntt_w);
    sc_ntt->fwd_ntt_32_16(Gn, ntt_params, G, ntt_w);
    sc_ntt->mul_32_pointwise(fn, ntt_params, fn, Gn);

    // Calculate gF
    sc_ntt->fwd_ntt_32_16(gn, ntt_params, g, ntt_w);
    sc_ntt->fwd_ntt_32_16(Fn, ntt_params, F, ntt_w);
    sc_ntt->mul_32_pointwise(gn, ntt_params, gn, Fn);

    // Calculate fG - gF
    sc_poly->sub_32(gn, n, fn, gn);
    sc_ntt->normalize_32(gn, n, ntt_params);

    // Verify that fG - gF = q = 0 mod q
    for (i=0; i<n; i++) {
        if (0 != gn[i]) {
            goto finish;
        }
    }

    retval = SC_FUNC_SUCCESS;

finish:
    SC_FREE(temp, sizeof(SINT32) * n * 3);
    return retval;
}

static SINT32 create_public_key(SINT32 *h, const SINT32 *f, const SINT32 *g, UINT32 q, size_t n)
{
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    SINT16 ntt_w[n];
    SINT16 ntt_r[n];
    SINT32 temp[n];

    // Dynamically allocate memory for the necessary NTT tables
    roots_of_unity_s16(ntt_w, ntt_r, n, q, 0);

    ntt_params_t ntt_q;
    init_reduce(&ntt_q, n, q);

    // Obtain NTT(f) and NTT(g)
    sc_ntt->fwd_ntt_32_16(h, &ntt_q, f, ntt_w);
    sc_ntt->fwd_ntt_32_16(temp, &ntt_q, g, ntt_w);

    // Attempt to invert NTT(f)
    if (SC_FUNC_FAILURE == sc_ntt->invert_32(h, &ntt_q, n)) {
        return SC_FUNC_FAILURE;
    }

    // h = g/f and f is invertible, so calculate public key
    sc_ntt->mul_32_pointwise(h, &ntt_q, temp, h);
    sc_ntt->inv_ntt_32_16(h, &ntt_q, h, ntt_w, ntt_r);
    sc_ntt->normalize_32(h, n, &ntt_q);

#if DEBUG_GPV == 1
    size_t i;
    fprintf(stderr, "\nh = g/f mod q =\n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", h[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
#endif

    return SC_FUNC_SUCCESS;
}

SINT32 gpv_gen_basis(safecrypto_t *sc, SINT32 *f, SINT32 *g, SINT32 *h,
    size_t n, SINT32 q,
    utils_sampling_t *sampling, prng_ctx_t *prng_ctx,
    SINT32 *F, SINT32 *G, SINT32 recreate_flag)
{
    size_t i, j;
    DOUBLE sigma;
    DOUBLE gs_norm;
    SINT32 retval = -1, num_retries = 0;
#if CRT_NTRU_SOLVE == 0
    sc_mpz_t Rf, Rg, gcd1, gcd2;
    sc_poly_mpz_t rho_f, rho_g, rho_dummy;
    sc_mpz_t alpha, beta, mp_q;
    sc_poly_mpz_t mp_f, mp_g;
    sc_mpz_t qv, qu;
    sc_poly_mpz_t pF, pG;
    sc_poly_mpz_t polymod;
    sc_poly_mpz_t pfbar, pgbar;
    sc_poly_mpz_t temp, num, den, k;
    sc_poly_mpz_t inv_f;
    sc_mpz_t scale;
#endif

    SC_TIMER_INSTANCE(timer);
    SC_TIMER_CREATE(timer);
    SC_TIMER_RESET(timer);

    SC_TIMER_INSTANCE(total_timer);
    SC_TIMER_CREATE(total_timer);
    SC_TIMER_RESET(total_timer);

#if CRT_NTRU_SOLVE == 0
    sc_mpz_init(&Rf);
    sc_mpz_init(&Rg);
    sc_mpz_init(&gcd1);
    sc_mpz_init(&gcd2);
    sc_poly_mpz_init(&rho_f, n+1);
    sc_poly_mpz_init(&rho_g, n+1);
    sc_poly_mpz_init(&rho_dummy, n+1);
    sc_mpz_init(&alpha);
    sc_mpz_init(&beta);
    sc_poly_mpz_init(&mp_f, n);
    sc_poly_mpz_init(&mp_g, n);
    sc_mpz_init(&mp_q);
    sc_mpz_set_ui(&mp_q, q);

    // Computations are done mod x^N+1-----this defines this polynomial
    sc_poly_mpz_init(&polymod, n+1);
    sc_poly_mpz_set_si(&polymod, 0, 1);
    sc_poly_mpz_set_si(&polymod, n, 1);

    sc_poly_mpz_init(&pF, n);
    sc_poly_mpz_init(&pG, n);
    sc_mpz_init(&qv);
    sc_mpz_init(&qu);

    sc_poly_mpz_init(&pfbar, n);
    sc_poly_mpz_init(&pgbar, n);

    sc_poly_mpz_init(&temp, 2*n);
    sc_poly_mpz_init(&num, n);
    sc_poly_mpz_init(&den, n);
    sc_poly_mpz_init(&k, n);

    sc_poly_mpz_init(&inv_f, n);

    sc_mpz_init(&scale);
#endif

    SC_TIMER_START(timer);
    SC_TIMER_START(total_timer);

    // Step 1. set standard deviation of Gaussian distribution
    DOUBLE bd;
    bd  = 1.17*sqrt(q);

    // Step 2. Obtain f, g using Gaussian Samplers
    sigma  = 1.17 * sqrt(q / (2*n));
#if DEBUG_GPV == 1
    fprintf(stderr, "n=%zu, q=%d\n", n, q);
#endif
step2:
    // If f and g are already provided as inputs as we are recreating F and G
    // then do not sample new distributions
    if (0 == recreate_flag) {
        get_vector_32(sampling, f, n, 0);
        get_vector_32(sampling, g, n, 0);
        /*SINT32 f_set[256] = {-7, 2, 2, -2, 3, 0, -7, 2, 4, 0, 7, -3, -1, -2, 0, 1, -2, -3, -3, -8, -8, 8, -1, -2, 3, 10, 0, -7, -5, -2, 3, 5, 4, -6, -1, -8, 2, 5, 7, 4, 3, 1, -4, -2, 3, 1, 5, 10, -2, -5, -2, 6, 1, 6, -3, -2, 2, 1, 3, 7, 3, 2, -3, -2, 1, 0, 2, 0, 6, 7, 4, -1, 0, -2, 5, -3, -3, 9, -3, -4, 6, -9, -8, -2, 3, -6, -1, 1, 1, 6, -2, 6, -3, -4, -3, -6, 4, 4, 6, 3, -1, 3, 7, 5, -4, -6, 6, 4, 3, 3, -3, -6, 2, 1, 0, -3, 0, -7, 3, 3, 2, 1, 2, -4, -11, 0, -1, 3, 8, 8, 2, -5, 3, -1, 1, -5, -8, 7, 2, -3, -1, 8, 0, -2, 2, -3, 1, -7, 5, 8, -10, 2, -4, 5, 0, 3, -1, -4, -2, -2, 1, 11, 7, -3, -2, 0, 0, 1, 3, -2, 1, -2, -2, 4, 2, 3, -3, -7, 7, 1, 2, -1, -2, -1, -2, 2, 5, 5, 4, -1, 3, -3, -1, 2, 4, -1, 2, 5, -2, 5, 1, 3, -1, -4, 0, 0, 0, -3, 9, 2, -1, 5, -1, 4, 1, 6, 1, 1, -6, 5, 3, -7, 0, 1, 1, 2, 0, 3, 0, 4, -3, -7, 3, 2, 0, -1, -6, -1, -3, -8, -3, 3, 0, 3, 4, 0, -3, 3, 6, -1, -4, -5, 5, 4, 2, 1}; 
        SINT32 g_set[256] = {10, -1, -6, 1, -5, 2, -2, 4, -5, -3, -11, 3, -1, -1, -1, 8, 3, -7, 4, 4, -3, -3, 3, 1, -2, 12, 5, 2, -2, -1, 6, 3, -1, 2, 6, -6, -3, -2, 5, 2, 6, -13, 3, 1, 2, 9, 3, 2, -15, 0, -4, 1, -3, 0, -2, 5, -2, 6, -3, 3, -1, 1, 0, 13, -4, 8, 2, -2, -6, -12, -7, 7, 9, 4, -5, 5, 9, 4, -3, 6, -4, 3, 1, 0, 0, 5, 6, -1, -6, 0, 3, -1, 1, -2, 0, 5, -4, 2, 2, -8, 3, -3, 0, 7, 6, -1, -4, 0, 8, -4, -7, -4, -2, -5, -2, -14, 0, 7, -5, 3, 5, 1, 3, 0, 6, -3, 4, 6, -6, -5, -2, 2, -1, -3, 4, 1, -7, -1, -2, -4, 0, 0, -5, 2, -8, -2, -2, -3, -3, -2, 5, 0, 0, 0, 3, 4, -3, -3, -3, 0, -6, 1, -3, 2, -3, 3, 6, 5, 2, -4, 1, -1, 6, -1, -2, -3, 2, -1, -4, 4, -3, 2, -6, -5, 2, 2, 6, -1, 10, 2, -5, -3, -2, -5, 3, -2, -1, -4, -6, 3, -6, 0, -1, -6, -1, 4, 1, -2, 5, 3, -5, -5, 6, 0, 9, -1, -3, -2, 4, -2, -5, 5, 4, 7, 6, 0, -2, 2, 10, 8, 5, 2, -1, -11, 7, 0, 8, 6, -3, -5, 3, -3, -5, 6, 2, -6, 8, -4, 0, -2, 3, 2, 3, -15, -1, 8};
        for (i=0; i<n; i++) {
            f[i] = f_set[i];
            g[i] = g_set[i];
        }*/
    }
    else {
        // If we are recreating the private key and we require a restart then
        // there has been an error
        goto finish;
    }

    // Step 3. calculate the GramSchmidt norm
    gs_norm = gram_schmidt_norm(f, g, n, q, bd);
    if (isnanl(gs_norm)) {
        num_retries++;
        goto step2;
    }

    // Step 4. check whether norm is small enough; if not, repeat
    if (gs_norm > bd) {
        num_retries++;
        goto step2;
    }
#if DEBUG_GPV == 1
    fprintf(stderr, "GS=%3.3f, threshold=%3.3f\n", gs_norm, bd);
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute GS Norm: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);



    ntt_params_t *ntt_params = (SC_SCHEME_SIG_FALCON == sc->scheme)? &sc->falcon->ntt  :
                               (SC_SCHEME_IBE_DLP    == sc->scheme)? &sc->dlp_ibe->ntt :
                                                                     &sc->ens_dlp_sig->ntt;
    const SINT16 *ntt_w_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->w  :
                          //(SC_SCHEME_IBE_DLP    == sc->scheme)? sc->dlp_ibe->params->w :
                                                                sc->ens_dlp_sig->params->w;
    const SINT16 *ntt_r_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->r  :
                          //(SC_SCHEME_IBE_DLP    == sc->scheme)? sc->dlp_ibe->params->r :
                                                                sc->ens_dlp_sig->params->r;
    const SINT32 *ntt_w_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->w : 0;
    const SINT32 *ntt_r_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->r : 0;
#if CRT_NTRU_SOLVE == 1
    /*if (SC_FUNC_SUCCESS != field_norm_ntru_solve(f, g, F, G, q, sc_log2_32(n))) {
        num_retries++;
        goto step2;
    }*/

    falcon_keygen *fk = falcon_keygen_new(sc, ntt_params, ntt_w_16, ntt_r_16, sc_log2_32(n));
    int16_t F16[1024], G16[1024], f16[1024], g16[1024];
    for (size_t i=0; i<n; i++) {
        f16[i] = f[i];
        g16[i] = g[i];
    }
    if (!solve_NTRU(fk, F16, G16, f16, g16)) {
        falcon_keygen_free(fk);
        goto step2;
    }
    for (size_t i=0; i<n; i++) {
        F[i] = F16[i];
        G[i] = G16[i];
    }
    falcon_keygen_free(fk);

    /*fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "F = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", F[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "G = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", G[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");*/
#else

    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);

    // Step 5, 6, 7. Polynomial Euclidean to find 4 unknowns
    //poly_mpi_reset(&rho_f, 0);
    sc_poly_mpz_xgcd(&mp_f, &polymod, &Rf, &rho_f, &rho_dummy);
    sc_mpz_gcd(&Rf, &mp_q, &gcd2);

#if DEBUG_GPV == 1
    fprintf(stderr, "GCD(Rf,q) = "); sc_mpz_out_str(stderr, 16, &gcd2); fprintf(stderr, "\n");
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute XGCD(f,phi): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    if (0 != sc_mpz_cmp_ui(&gcd2, 1)) {
        // It is more efficient to check that gcd(Rf,q) == 1 early
        num_retries++;
        goto step2;
    }
    sc_poly_mpz_xgcd(&mp_g, &polymod, &Rg, &rho_g, &rho_dummy);
    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute XGCD(g,phi): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    sc_mpz_xgcd(&Rf, &Rg, &gcd1, &alpha, &beta);
    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute GCD(Rf,Rg): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    if (1 != sc_mpz_get_ui(&gcd1)) {
        // The gcd(Rf,Rg) and the computation of u and v are performed
        // together for efficiency
        num_retries++;
        goto step2;
    }
#if DEBUG_GPV == 1
    fprintf(stderr, "GCD(Rf,Rg) = 1\n");
#endif
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "f", f, n);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "g", g, n);

    SC_TIMER_STOP(timer);
    SC_TIMER_STOP(total_timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute f and g: %3.3f sec\n", SC_TIMER_GET_ELAPSED(total_timer));
#endif

    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);
    SC_TIMER_START(total_timer);

    // Step 8. Calculate the polynomials F, G
    sc_mpz_mul_si(&qv, &beta, -q);
    sc_mpz_mul_si(&qu, &alpha, q);
    sc_poly_mpz_mul_scalar(&pF, &rho_g, &qv); // F = -q * rho_g * beta
    sc_poly_mpz_mul_scalar(&pG, &rho_f, &qu); // G = q * rho_f * alpha

    // Step 9. Calculate f-bar, g-bar and the reduction factor k
    sc_poly_mpz_reverse(&pfbar, n, &mp_f);
    sc_poly_mpz_reverse(&pgbar, n, &mp_g);

    // k = (F*fb + G*gb) / (f*fb + g*gb)
    sc_poly_mpz_mul(&temp, &mp_f, &pfbar);
    sc_poly_mpz_addmul(&temp, &mp_g, &pgbar);
    sc_poly_mpz_mod_ring(&den, n, &temp);

#if DEBUG_GPV == 1
    fprintf(stderr, "XGCD scale computation ...\n");
#endif
#ifdef ENABLE_CALLGRIND_PROFILING
    CALLGRIND_START_INSTRUMENTATION;
#endif
    SINT32 errcode = sc_poly_mpz_xgcd(&den, &polymod, &scale, &rho_g, &rho_dummy);
    if (SC_FUNC_FAILURE == errcode) {
        fprintf(stderr, "ERROR! sc_poly_mpz_xgcd() failed\n");
        goto finish;
    }
#ifdef ENABLE_CALLGRIND_PROFILING
    CALLGRIND_STOP_INSTRUMENTATION;
    CALLGRIND_DUMP_STATS;
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to scale: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

#if DEBUG_GPV == 1
    fprintf(stderr, "Computing reduction factor k ...\n");
#endif

    //poly_mpi_reset(&temp, 0);
    sc_poly_mpz_mul(&temp, &pF, &pfbar);
    sc_poly_mpz_addmul(&temp, &pG, &pgbar);
    sc_poly_mpz_mod_ring(&num, n, &temp);

    // den * rho_g + polymod * rho_dummy = gcd(den, polymod) = scale
    // => den * rho_g = scale
    // => 1/den = rho_g / scale
    // Therefore, k = num/den = num * rho_g / scale
    sc_poly_mpz_mul(&temp, &num, &rho_g);
    sc_poly_mpz_mod_ring(&k, n, &temp);
#if DEBUG_GPV == 1
    fprintf(stderr, "Scaling reduction factor k ...\n");
#endif
    for (size_t i=n; i--;) {
        sc_mpz_divquo(&k.p[i], &k.p[i], &scale);
    }

    // Step 10. Reduce F and G
#if DEBUG_GPV == 1
    fprintf(stderr, "Reducing F and G ...\n");
    /*fprintf(stderr, "k = \n");
    for (i=0; i<n; i++) {
        sc_mpz_out_str(stderr, 10, &k.p[i]);
        fprintf(stderr, " ");
        if (7 == (7&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");*/
#endif
    SINT32 deg_k = sc_poly_mpz_degree(&k);
    for (j=0; j<16; j++) {
    //while (deg_k >= 0 && !sc_mpz_is_zero(&k.p[0])) {
        sc_poly_mpz_mul(&temp, &k, &mp_f);
        sc_poly_mpz_sub(&temp, &pF, &temp);      // F = F - k*f
        sc_poly_mpz_mod_ring(&pF, n, &temp);
        sc_poly_mpz_mul(&temp, &k, &mp_g);
        sc_poly_mpz_sub(&temp, &pG, &temp);      // G = G - k*g
        sc_poly_mpz_mod_ring(&pG, n, &temp);

        sc_poly_mpz_mul(&temp, &pF, &pfbar);
        sc_poly_mpz_addmul(&temp, &pG, &pgbar);
        sc_poly_mpz_mod_ring(&num, n, &temp);

        sc_poly_mpz_mul(&temp, &num, &rho_g);
        sc_poly_mpz_mod_ring(&k, n, &temp);
        for (size_t i=n; i--;) {
            sc_mpz_divquo(&k.p[i], &k.p[i], &scale);
        }

        deg_k = sc_poly_mpz_degree(&k);
        if (0 == deg_k && sc_mpz_is_zero(&k.p[0])) {
            break;
        }
        if (15 == j) {
#if DEBUG_GPV == 1
            fprintf(stderr, "Cannot reduce F and G ...\n");
#endif
            num_retries++;
            goto finish;
        }
    }

    for (i=n; i--;) {
        F[i] = sc_poly_mpz_get_si(&pF, i);
        G[i] = sc_poly_mpz_get_si(&pG, i);
    }
#endif


#if DEBUG_GPV == 1
    fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    SINT32 sum = 0;
    fprintf(stderr, "F = \n");
    for (i=0; i<n; i++) {
        sum += F[i] * F[i];
        fprintf(stderr, "%6d ", F[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);
    sum = 0;
    fprintf(stderr, "G = \n");
    for (i=0; i<n; i++) {
        sum += G[i] * G[i];
        fprintf(stderr, "%6d ", G[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);

    fprintf(stderr, "Verifying master key ...\n");
#endif


#if CRT_NTRU_SOLVE == 0
#if SP_PUBLIC_KEY_CREATE == 1
    if (SC_SCHEME_IBE_DLP == sc->scheme) {
        if (SC_FUNC_FAILURE == verify_private_key_32(sc, f, g, F, G, q, n, ntt_w_32, ntt_r_32, ntt_params)) {
            num_retries++;
            goto step2;
        }
    }
    else {
        if (SC_FUNC_FAILURE == verify_private_key_16(sc, f, g, F, G, q, n, ntt_w_16, ntt_r_16, ntt_params)) {
            num_retries++;
            goto step2;
        }
    }
#else
    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);
    poly_si32_to_mpi(&pF, n, F);
    poly_si32_to_mpi(&pG, n, G);

    // Verify that the NTRU equation is solved
    sc_poly_mpz_mul(&temp, &pG, &mp_f);
    sc_poly_mpz_submul(&temp, &pF, &mp_g);      // F = F - k*f
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    UINT32 verify = sc_mpz_get_ui(&temp.p[0]);

#if DEBUG_GPV == 1
    fprintf(stderr, "    q = 0x%08X, f*G - g*F = 0x%08X :: %s\n",
        q, verify, (q == verify)? "VERIFIED" : "FAILED");
#endif
    if (q != verify) {
        num_retries++;
        goto step2;
    }
#endif
#endif



    // Step 11. Compute the public key h = g/f mod q
#if SP_PUBLIC_KEY_CREATE == 1
    if (SC_FUNC_FAILURE == create_public_key(h, f, g, q, n)) {
        num_retries++;
        goto step2;
    }
#else
    sc_mod_t modulus;
    limb_mod_init(&modulus, q);

    // Don't need this as it's done above ...
    //poly_mpi_xgcd(&mp_f, &polymod, &Rg, &rho_dummy, &rho_f);

    sc_poly_mpz_xgcd(&mp_f, &polymod, &Rf, &rho_f, &rho_dummy);
    sc_mpz_invmod(&Rf, &Rf, &mp_q);
    sc_poly_mpz_mul_scalar(&inv_f, &rho_f, &Rf);

    sc_poly_mpz_mul(&temp, &inv_f, &mp_f);
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &modulus);

    for (i=0; i<n; i++) {
        sc_slimb_t val = sc_poly_mpz_get_si(&temp, i);
        if (0 == i && 1 != val) {
            num_retries++;
            goto step2;
        }
        if (0 != i && 0 != val) {
            num_retries++;
            goto step2;
        }
    }

    sc_poly_mpz_mul(&temp, &mp_g, &inv_f);
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &modulus);

    for (i=n; i--;) {
        h[i] = sc_poly_mpz_get_si(&temp, i);
    }

#if DEBUG_GPV == 1
    fprintf(stderr, "\nh = g/f mod q =\n");
    for (i=0; i<n; i++) {
        sc_mpz_out_str(stderr, 10, &temp.p[i]);
        fprintf(stderr, " ");
        if (7 == (7&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
#endif
#endif

    retval = num_retries;

#if DEBUG_GPV == 1
    fprintf(stderr, "Polynomial basis found\n");
#endif

finish:
#if CRT_NTRU_SOLVE == 0
    sc_poly_mpz_clear(&inv_f);
    sc_mpz_clear(&Rf);
    sc_mpz_clear(&Rg);
    sc_mpz_clear(&gcd1);
    sc_mpz_clear(&gcd2);
    sc_poly_mpz_clear(&polymod);
    sc_poly_mpz_clear(&rho_f);
    sc_poly_mpz_clear(&rho_g);
    sc_poly_mpz_clear(&rho_dummy);
    sc_mpz_clear(&alpha);
    sc_mpz_clear(&beta);
    sc_poly_mpz_clear(&mp_f);
    sc_poly_mpz_clear(&mp_g);
    sc_mpz_clear(&mp_q);
    sc_poly_mpz_clear(&pF);
    sc_poly_mpz_clear(&pG);
    sc_mpz_clear(&qv);
    sc_mpz_clear(&qu);
    sc_mpz_clear(&scale);
    sc_poly_mpz_clear(&pfbar);
    sc_poly_mpz_clear(&pgbar);
    sc_poly_mpz_clear(&temp);
    sc_poly_mpz_clear(&num);
    sc_poly_mpz_clear(&den);
    sc_poly_mpz_clear(&k);
#endif

    SC_TIMER_STOP(timer);
    SC_TIMER_STOP(total_timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute F, G and h: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
    fprintf(stderr, "Total time: %3.3f sec\n", SC_TIMER_GET_ELAPSED(total_timer));
#endif

    SC_TIMER_DESTROY(timer);
    SC_TIMER_DESTROY(total_timer);

    return retval;
}

SINT32 gaussian_lattice_sample_on_the_fly_flt(safecrypto_t *sc,
    const gpv_t *gpv, const FLOAT *b_gs, const FLOAT *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    FLOAT sig = 0L;
    for (j=2*n; j--;) {
        FLOAT d, dot_product;
        dot_product = dot_s64_flt(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_on_the_fly_dbl(safecrypto_t *sc,
    const gpv_t *gpv, const DOUBLE *b_gs, const DOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    DOUBLE sig = 0L;
    for (j=2*n; j--;) {
        DOUBLE d, dot_product;
        dot_product = dot_s64_dbl(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_on_the_fly_ldbl(safecrypto_t *sc,
    const gpv_t *gpv, const LONGDOUBLE *b_gs, const LONGDOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    LONGDOUBLE ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    LONGDOUBLE sig = 0L;
    for (j=2*n; j--;) {
        LONGDOUBLE d, dot_product;
        dot_product = dot_ldbl(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_flt(safecrypto_t *sc,
    const gpv_t *gpv, const FLOAT *b_gs, const FLOAT *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;
    SINT64 z;
    SINT32 is_efficient = flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    if (flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP) {
        gauss = sc->sc_gauss;
    }
    FLOAT sig = 0L;
    for (j=2*n; j--;) {
        FLOAT d, dot_product;
        dot_product = dot_s64_flt(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP) {
            sig = s_f * b_gs_inv_norm[j];
            z = get_bootstrap_sample(gauss, sig, d);
        }
        else {
            if ((is_efficient && (0L == sig)) || !is_efficient) {
                sig = s_f * b_gs_inv_norm[j];
    
                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                    return SC_FUNC_FAILURE;
                }
            }
    
            z = get_sample(gauss) + (SINT32) d;
        }

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (!(flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP)) {
            if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
                if (j == n) {
                    sig = 0L;
                    destroy_sampler(&gauss);
                }
            }
            else {
                destroy_sampler(&gauss);
            }
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_dbl(safecrypto_t *sc,
    const gpv_t *gpv, const DOUBLE *b_gs, const DOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    DOUBLE sig = 0L;
    for (j=2*n; j--;) {
        DOUBLE d, dot_product;
        dot_product = dot_s64_dbl(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (0L == sig) {
                sig = s_f * b_gs_inv_norm[j];

                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                   return SC_FUNC_FAILURE;
                }
            }
        }
        else {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT64 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (j == n) {
                sig = 0L;
                destroy_sampler(&gauss);
            }
        }
        else {
            destroy_sampler(&gauss);
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_ldbl(safecrypto_t *sc,
    const gpv_t *gpv, const LONGDOUBLE *b_gs, const LONGDOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    LONGDOUBLE ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    LONGDOUBLE sig = 0L;
    for (j=2*n; j--;) {
        LONGDOUBLE d, dot_product;
        dot_product = dot_ldbl(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (0L == sig) {
                sig = s_f * b_gs_inv_norm[j];

                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                    return SC_FUNC_FAILURE;
                }
            }
        }
        else {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT64 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (j == n) {
                sig = 0L;
                destroy_sampler(&gauss);
            }
        }
        else {
            destroy_sampler(&gauss);
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

#ifdef DEBUG_ENCRYPTION
static SINT32 gaussian_lattice_sample_debug(safecrypto_t *sc,
    const gpv_t *gpv, const GSO_TYPE *b_gs, const GSO_TYPE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    const SINT32 *w        = sc->dlp_ibe->params->w;
    const SINT32 *r        = sc->dlp_ibe->params->r;
    ntt_params_t *ntt      = &sc->dlp_ibe->ntt;
    const utils_arith_ntt_t *sc_ntt = sc->dlp_ibe->sc_ntt;
    const utils_arith_poly_t *sc_poly  = sc->dlp_ibe->sc_poly;

    // Verification - prove that ((s1 - t)*f + g*s2) = 0
    SINT32 *t = SC_MALLOC(sizeof(SINT32) * 4 * n);
    SINT32 *s1, *s2, *f, *g;
    SINT32 deg;
    s1 = t;
    s2 = t + n;
    f = t + 2 * n;
    g = t + 3 * n;
    for (j=0; j<n; j++) {
        s1[j] = (SINT32) ci[j];
        s2[j] = v[j];
        f[j] = -gpv->b[n+j];
        g[j] = gpv->b[j];
    }

    sc_poly->sub_single_32(s1, n, c);

    // Verification without NTT
    sc_poly_mpz_t pf, pg;
    sc_poly_mpz_t mp_f, mp_g, mp_h;
    sc_poly_mpz_t temp;
    sc_poly_mpz_init(&temp, 2*n);
    sc_poly_mpz_init(&pf, n);
    sc_poly_mpz_init(&pg, n);
    sc_poly_mpz_init(&mp_f, n);
    sc_poly_mpz_init(&mp_g, n);
    sc_poly_mpz_init(&mp_h, n);

    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);
    poly_si32_to_mpi(&mp_h, n, sc->pubkey->key);
    poly_si32_to_mpi(&pf, n, s1);
    poly_si32_to_mpi(&pg, n, s2);

    sc_mod_t mod;
    limb_mod_init(&mod, sc->dlp_ibe->params->q);

    sc_poly_mpz_mul(&temp, &pf, &mp_f);
    sc_poly_mpz_addmul(&temp, &pg, &mp_g);      // (s1 - c)*f + s2*g
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &mod);
    SINT32 deg_mpi_1 = sc_poly_mpz_degree(&temp);

    sc_poly_mpz_mul(&temp, &pg, &mp_h);
    sc_poly_mpz_add(&temp, &temp, &pf);      // (s1 - c) + s2*h
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &mod);
    SINT32 deg_mpi_2 = sc_poly_mpz_degree(&temp);

    // Verification with NTT - (s1 - c)*f + s2*g
    sc_ntt->fwd_ntt_32_32_large(s1, ntt, s1, w);
    sc_ntt->fwd_ntt_32_32_large(s2, ntt, s2, w);
    sc_ntt->fwd_ntt_32_32_large(f, ntt, f, w);
    sc_ntt->fwd_ntt_32_32_large(g, ntt, g, w);

    sc->dlp_ibe->sc_ntt->mul_32_pointwise(s1, ntt, s1, f); // NTT(s1 - c) * NTT(f)
    sc->dlp_ibe->sc_ntt->mul_32_pointwise(s2, ntt, s2, g); // NTT(s2) * NTT(g)
    sc_ntt->inv_ntt_32_32_large(s1, ntt, s1, w, r);
    sc_ntt->inv_ntt_32_32_large(s2, ntt, s2, w, r);
    sc_poly->add_32(f, n, s1, s2);
    sc_ntt->normalize_32(f, n, ntt);
    deg = poly_32_degree(f, n);

    if (!(0 == deg && 0 == f[deg])) {
        SC_FREE(t, sizeof(SINT32) * 4 * n);

        sc_poly_mpz_clear(&temp);
        sc_poly_mpz_clear(&pf);
        sc_poly_mpz_clear(&pg);
        sc_poly_mpz_clear(&mp_f);
        sc_poly_mpz_clear(&mp_g);
        sc_poly_mpz_clear(&mp_h);

        goto restart;
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "(s1-c)*f + s2*g", s1, n);

    SC_FREE(t, sizeof(SINT32) * 4 * n);

    sc_poly_mpz_clear(&temp);
    sc_poly_mpz_clear(&pf);
    sc_poly_mpz_clear(&pg);
    sc_poly_mpz_clear(&mp_f);
    sc_poly_mpz_clear(&mp_g);
    sc_poly_mpz_clear(&mp_h);

    return SC_FUNC_SUCCESS;
}
#endif

